// load network.js to get network/chain id
document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "./network.js" }));
// load web3modal to connect to wallet
//document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "./web3/lib/web3modal.js" }));
// document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "https://unpkg.com/web3modal@1.9.4/dist/index.js" }));

// load web3js to create transactions
//document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "./web3/lib/web3.min.js" }));
// document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "https://unpkg.com/web3@1.2.11/dist/web3.min.js" }));

// uncomment to enable torus wallet
// document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "https://unpkg.com/@toruslabs/torus-embed" }));
// uncomment to enable walletconnect
// document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "https://unpkg.com/@walletconnect/web3-provider@1.7.1/dist/umd/index.min.js" }));

// load google-analytics.js to get access to analytics
document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "./js/google-analytics.js" }));

document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "./web3/borsh.bundle.js" }));

//document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "./web3/concordium.min.js" }));

// load nearAPI.js to get access to Near APIW
document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "./web3/nearAPI.js" }));

import { Web3Modal } from 'https://unpkg.com/@web3modal/html'

// load web3gl to connect to unity
window.web3gl = {
    networkId: 0,
    connect,
    connectAccount: "",
    signMessage,
    signMessageResponse: "",
    sendTransaction,
    sendTransactionResponse: "",
    sendContract,
    sendContractResponse: "",
    addNetwork,
    addNetworkResponse: "",
    changeChainId,
    getAllErc721,
    getAllErc721Response: "",
    getLatestEpoch,
    getLatestEpochResponse: "",
    methodCall,
    methodCallResponse: "",
    getTxStatus,
    getTxStatusResponse: "",
    getBalance,
    getBalanceResponse: "",
    connectNearWallet,
    connectNearWalletAccount: "",
    nearSendContract,
    nearSendContractResponse: "",
    nearMethodCall,
    nearMethodCallResponse: "",
    listNearNFTsWeb,
    listNearNFTsWebResponse: "",
    nearLatestEpoch,
    nearLatestEpochResponse: "",
    webGLReload,
    googleAnalyticsSendEvent

};

let bin64;

const testCCDBin64 = '//8DAQAAAAcAAABNT1RPREVYAQAUAAMAAAALAAAAbWluaW1hbF9mZWUKGQAAAG1pbl9nYW1lX3Nlc3Npb25fZHVyYXRpb24FEgAAAG1pbl9lcG9jaF9pbnRlcnZhbAUvAAAADgAAAGFkZEhlYWx0aE1vbmV5BBQAAQAAAAgAAAB0b2tlbl9pZB0AFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CDAAAAGFkZEhlYWx0aE5mdAQUAAQAAAAIAAAAdG9rZW5faWQdABQAAABoZWFsdGhfcGlsbF90b2tlbl9pZB0ABgAAAGFtb3VudBslAAAABQAAAG93bmVyFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADBUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAgcAAABhZGRNb3RvBBQAAgAAAAgAAAB0b2tlbl9pZB0ADgAAAHByZXZpb3VzX293bmVyFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADBUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAggAAABhZGRUcmFjawQUAAIAAAAIAAAAdG9rZW5faWQdAA4AAABwcmV2aW91c19vd25lchUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIJAAAAYmFsYW5jZU9mBhABFAACAAAACAAAAHRva2VuX2lkHQAHAAAAYWRkcmVzcxUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwQARslAAAAFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CBgAAAGJpZEZvcgQUAAIAAAAOAAAAdHJhY2tfdG9rZW5faWQdAA0AAABtb3RvX3Rva2VuX2lkHQAVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIVAAAAY3JlYXRlT3JVcGRhdGVTZXNzaW9uBBQAAwAAAA4AAAB0cmFja190b2tlbl9pZB0ADQAAAG1vdG9fdG9rZW5faWQdABYAAABsYXN0X3RyYWNrX3RpbWVfcmVzdWx0DhUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAhQAAABnZXRBY3RpdmVTZXNzaW9uc0lkcwEQAh0ABwAAAGdldEJpZHMBEAIUAAUAAAAOAAAAdHJhY2tfdG9rZW5faWQdAAYAAABhbW91bnQKDQAAAG1vdG9fdG9rZW5faWQdAAkAAAB0aW1lc3RhbXAFBgAAAGJpZGRlchUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwUAAAAZ2V0RmluaXNoaW5nU2Vzc2lvbnMBEAIdAA4AAABnZXRMYXRlc3RQcmljZQEKGwAAAGdldE1vdG9kZXhNZXRhZGF0YUJ5VHlwZU5mdAIUAAEAAAAIAAAAdHlwZV9uZnQCFAAHAAAABAAAAG5hbWUWAgsAAABkZXNjcmlwdGlvbhYCCAAAAHR5cGVfbmZ0Ag4AAABjdXJyZW50X3N1cHBseQQKAAAAdHlwZV9saW1pdAQOAAAAdHlwZV9wcmljZV91c2QKAwAAAHVyaRYCEgAAAGdldFBlcmNlbnRGb3JUcmFjawIUAAEAAAAIAAAAdG9rZW5faWQdAAIPAAAAZ2V0UHJpY2VGb3JUeXBlAhQAAQAAAAgAAAB0eXBlX25mdAIKCwAAAGdldFNlc3Npb25zARACFAAMAAAADgAAAHRyYWNrX3Rva2VuX2lkHQAKAAAAdHJhY2tfdHlwZQIMAAAAdHJhY2tfaGVhbHRoCgkAAABpbml0X3RpbWUFDAAAAHBhcnRpY2lwYW50cxACFAAFAAAADQAAAG1vdG9fb3duZXJfaWQVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAG1vdG9fdG9rZW5faWQdAAkAAABtb3RvX3R5cGUCCwAAAG1vdG9faGVhbHRoChAAAABiZXN0X3RpbWVfcmVzdWx0BRIAAABsYXRlc3RfdXBkYXRlX3RpbWUFGAAAAGxhdGVzdF90cmFja190aW1lX3Jlc3VsdAUIAAAAYXR0ZW1wdHMCDQAAAGdhbWVfYmlkc19zdW0KDQAAAGdhbWVfZmVlc19zdW0KEwAAAGN1cnJlbnRfd2lubmVyX21vdG8VAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAUAAMAAAANAAAAbW90b19vd25lcl9pZBUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwNAAAAbW90b190b2tlbl9pZB0AFgAAAGxhc3RfdHJhY2tfdGltZV9yZXN1bHQODQAAAGVwb2NoX3BheW1lbnQQAhUEAAAABQAAAFRyYWNrAQEAAAAUAAQAAAAOAAAAdHJhY2tfdG9rZW5faWQdAAYAAABhbW91bnQKCwAAAHJlY2VpdmVyX2lkFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADA0AAABtb3RvX3Rva2VuX2lkFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAHQAEAAAATW90bwEBAAAAFAAEAAAADgAAAHRyYWNrX3Rva2VuX2lkHQAGAAAAYW1vdW50CgsAAAByZWNlaXZlcl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAABUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwNAAAAbW90b190b2tlbl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ABgAAAEJpZGRlcgEBAAAAFAAEAAAADgAAAHRyYWNrX3Rva2VuX2lkHQAGAAAAYW1vdW50CgsAAAByZWNlaXZlcl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAABUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwNAAAAbW90b190b2tlbl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ACAAAAFBsYXRmb3JtAAIAAAAGAAAAYW1vdW50Cg4AAAB0cmFja190b2tlbl9pZB0ADgAAAGdldFRva2VuSGVhbHRoAhQAAQAAAAgAAAB0b2tlbl9pZB0ACg0AAABnZXRUb2tlbk93bmVyAhQAAQAAAAgAAAB0b2tlbl9pZB0AFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADA4AAABnZXRUb2tlblR5cGVJZAIUAAEAAAAIAAAAdG9rZW5faWQdAAIPAAAAZ2V0VG9rZW5zSGVhbHRoARACDx0ACgQAAABtaW50BBQAAgAAAAUAAABvd25lchUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwGAAAAdG9rZW5zEQACFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CEgAAAG5mdFRva2Vuc0Zvck93bmVycwIUAAMAAAAHAAAAYWRkcmVzcxUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwKAAAAZnJvbV9pbmRleBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAAQFAAAAbGltaXQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAEEAIUAAMAAAAIAAAAdG9rZW5faWQdAAgAAABvd25lcl9pZBUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwIAAAAbWV0YWRhdGEUAAcAAAAEAAAAbmFtZRYCCwAAAGRlc2NyaXB0aW9uFgIIAAAAdHlwZV9uZnQCDgAAAGN1cnJlbnRfc3VwcGx5BAoAAAB0eXBlX2xpbWl0BA4AAAB0eXBlX3ByaWNlX3VzZAoDAAAAdXJpFgIKAAAAb3BlcmF0b3JPZgYQARQAAgAAAAUAAABvd25lchUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwHAAAAYWRkcmVzcxUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwQAQEVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIIAAAAcHVyY2hhc2UEFAACAAAACAAAAHJlZmVycmFsFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADAgAAAB0eXBlX25mdAIVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgINAAAAcHVyY2hhc2VCYXRjaAQUAAIAAAAIAAAAcmVmZXJyYWwVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAHR5cGVfbmZ0X2xpc3QQAgIVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIKAAAAcmV0dXJuTW90bwQUAAIAAAAIAAAAdG9rZW5faWQdAAkAAABuZXdfb3duZXIVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CCwAAAHJldHVyblRyYWNrBBQAAgAAAAgAAAB0b2tlbl9pZB0ACQAAAG5ld19vd25lchUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgINAAAAc2V0R2FtZVNlcnZlcgQUAAEAAAALAAAAZ2FtZV9zZXJ2ZXIVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CDgAAAHNldEhlYWx0aEZvcklkBBQAAgAAAAcAAAB0eXBlX2lkHQAFAAAAcHJpY2UFFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CDwAAAHNldEltcGxlbWVudG9ycwQUAAIAAAACAAAAaWQWAAwAAABpbXBsZW1lbnRvcnMQAgwVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgITAAAAc2V0TWluRXBvY2hJbnRlcnZhbAQUAAEAAAAIAAAAaW50ZXJ2YWwFFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CCQAAAHNldE1pbkZlZQQUAAEAAAAGAAAAYW1vdW50BRUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAhkAAABzZXRNaW5HYW1lU2Vzc2lvbkludGVydmFsBBQAAQAAAAgAAABpbnRlcnZhbAUVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgISAAAAc2V0UGVyY2VudEZvclRyYWNrBBQAAgAAAA4AAAB0cmFja190b2tlbl9pZB0ACgAAAHBlcmNlbnRhZ2UCFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CFwAAAHNldFBlcmNlbnRGb3JUcmFja093bmVyBBQAAgAAAA4AAAB0cmFja190b2tlbl9pZB0ACgAAAHBlcmNlbnRhZ2UCFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CDwAAAHNldFByaWNlRm9yVHlwZQQUAAIAAAAHAAAAdHlwZV9pZAIFAAAAcHJpY2UFFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CEwAAAHNldFByaWNlTWFpbkNvaW5Vc2QEFAABAAAABQAAAHByaWNlBRUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAggAAABzdXBwb3J0cwYQARYAEAEVAwAAAAkAAABOb1N1cHBvcnQCBwAAAFN1cHBvcnQCCQAAAFN1cHBvcnRCeQEBAAAAEAAMFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CCQAAAHN5bmNFcG9jaAYUAAEAAAAOAAAAdHJhY2tfdG9rZW5faWQdABQADAAAAA4AAAB0cmFja190b2tlbl9pZB0ACgAAAHRyYWNrX3R5cGUCDAAAAHRyYWNrX2hlYWx0aAoJAAAAaW5pdF90aW1lBQwAAABwYXJ0aWNpcGFudHMQAhQABQAAAA0AAABtb3RvX293bmVyX2lkFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADA0AAABtb3RvX3Rva2VuX2lkHQAJAAAAbW90b190eXBlAgsAAABtb3RvX2hlYWx0aAoQAAAAYmVzdF90aW1lX3Jlc3VsdAUSAAAAbGF0ZXN0X3VwZGF0ZV90aW1lBRgAAABsYXRlc3RfdHJhY2tfdGltZV9yZXN1bHQFCAAAAGF0dGVtcHRzAg0AAABnYW1lX2JpZHNfc3VtCg0AAABnYW1lX2ZlZXNfc3VtChMAAABjdXJyZW50X3dpbm5lcl9tb3RvFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAFAADAAAADQAAAG1vdG9fb3duZXJfaWQVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAG1vdG9fdG9rZW5faWQdABYAAABsYXN0X3RyYWNrX3RpbWVfcmVzdWx0Dg0AAABlcG9jaF9wYXltZW50EAIVBAAAAAUAAABUcmFjawEBAAAAFAAEAAAADgAAAHRyYWNrX3Rva2VuX2lkHQAGAAAAYW1vdW50CgsAAAByZWNlaXZlcl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAABUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwNAAAAbW90b190b2tlbl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ABAAAAE1vdG8BAQAAABQABAAAAA4AAAB0cmFja190b2tlbl9pZB0ABgAAAGFtb3VudAoLAAAAcmVjZWl2ZXJfaWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAG1vdG9fdG9rZW5faWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAdAAYAAABCaWRkZXIBAQAAABQABAAAAA4AAAB0cmFja190b2tlbl9pZB0ABgAAAGFtb3VudAoLAAAAcmVjZWl2ZXJfaWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAG1vdG9fdG9rZW5faWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAdAAgAAABQbGF0Zm9ybQACAAAABgAAAGFtb3VudAoOAAAAdHJhY2tfdG9rZW5faWQdABUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAhkAAABzeW5jRXBvY2hSZXN1bHRzQmlkc0ZpbmFsARACFAAFAAAADgAAAHRyYWNrX3Rva2VuX2lkHQANAAAAbW90b190b2tlbl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ABgAAAGFtb3VudAoCAAAAdG8VAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAHJlY2VpdmVyX3R5cGUWAhoAAABzeW5jRXBvY2hSZXN1bHRzTW90b3NGaW5hbAEQAhQABQAAAA4AAAB0cmFja190b2tlbl9pZB0ADQAAAG1vdG9fdG9rZW5faWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAdAAYAAABhbW91bnQKAgAAAHRvFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADA0AAAByZWNlaXZlcl90eXBlFgIaAAAAc3luY0Vwb2NoUmVzdWx0c1RvdGFsRmluYWwBEAIUAAUAAAAOAAAAdHJhY2tfdG9rZW5faWQdAA0AAABtb3RvX3Rva2VuX2lkFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAHQAGAAAAYW1vdW50CgIAAAB0bxUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAABUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwNAAAAcmVjZWl2ZXJfdHlwZRYCEQAAAHRva2VuSWRzQW5kT3duZXJzAhQAAgAAAAoAAABmcm9tX2luZGV4FQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAABAUAAABsaW1pdBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAAQQAhQABgAAAA4AAAB0cmFja190b2tlbl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ACgAAAHRyYWNrX3R5cGUVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAACDQAAAG1vdG9fdG9rZW5faWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAdAAkAAABtb3RvX3R5cGUVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAACCAAAAG93bmVyX2lkFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADA4AAABhY3RpdmVfc2Vzc2lvbhUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ADQAAAHRva2VuTWV0YWRhdGEGEAEdABABFAACAAAAAwAAAHVybBYBBAAAAGhhc2gVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAATIAAAAAIVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIIAAAAdHJhbnNmZXIEEAEUAAUAAAAIAAAAdG9rZW5faWQdAAYAAABhbW91bnQbJQAAAAQAAABmcm9tFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADAIAAAB0bxUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAgAAAAwWAQQAAABkYXRhHQEVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIOAAAAdXBkYXRlT3BlcmF0b3IEEAEUAAIAAAAGAAAAdXBkYXRlFQIAAAAGAAAAUmVtb3ZlAgMAAABBZGQCCAAAAG9wZXJhdG9yFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADBUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAg8AAAB2YWx1ZUluTWFpbkNvaW4CFAABAAAACAAAAHR5cGVfbmZ0AgoEAAAAdmlldwEUAAkAAAAFAAAAc3RhdGUQAg8VAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMFAACAAAADAAAAG93bmVkX3Rva2VucxACHQAJAAAAb3BlcmF0b3JzEAIVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMCgAAAGFsbF90b2tlbnMQAg8dABUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwHAAAAbWluX2ZlZQULAAAAbWluX2ZlZV91c2QFEgAAAG1pbl9lcG9jaF9pbnRlcnZhbAUTAAAAbGF0ZXN0X2Vwb2NoX3VwZGF0ZQUZAAAAbWluX2dhbWVfc2Vzc2lvbl9kdXJhdGlvbgUTAAAAcHJpY2VfbWFpbl9jb2luX3VzZAUHAAAAY291bnRlcgQA';
const mainCCDBin64 = '//8DAQAAAAcAAABNT1RPREVYAQAUAAMAAAALAAAAbWluaW1hbF9mZWUKGQAAAG1pbl9nYW1lX3Nlc3Npb25fZHVyYXRpb24FEgAAAG1pbl9lcG9jaF9pbnRlcnZhbAUvAAAADgAAAGFkZEhlYWx0aE1vbmV5BBQAAQAAAAgAAAB0b2tlbl9pZB0AFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CDAAAAGFkZEhlYWx0aE5mdAQUAAQAAAAIAAAAdG9rZW5faWQdABQAAABoZWFsdGhfcGlsbF90b2tlbl9pZB0ABgAAAGFtb3VudBslAAAABQAAAG93bmVyFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADBUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAgcAAABhZGRNb3RvBBQAAgAAAAgAAAB0b2tlbl9pZB0ADgAAAHByZXZpb3VzX293bmVyFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADBUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAggAAABhZGRUcmFjawQUAAIAAAAIAAAAdG9rZW5faWQdAA4AAABwcmV2aW91c19vd25lchUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIJAAAAYmFsYW5jZU9mBhABFAACAAAACAAAAHRva2VuX2lkHQAHAAAAYWRkcmVzcxUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwQARslAAAAFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CBgAAAGJpZEZvcgQUAAIAAAAOAAAAdHJhY2tfdG9rZW5faWQdAA0AAABtb3RvX3Rva2VuX2lkHQAVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIVAAAAY3JlYXRlT3JVcGRhdGVTZXNzaW9uBBQAAwAAAA4AAAB0cmFja190b2tlbl9pZB0ADQAAAG1vdG9fdG9rZW5faWQdABYAAABsYXN0X3RyYWNrX3RpbWVfcmVzdWx0DhUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAhQAAABnZXRBY3RpdmVTZXNzaW9uc0lkcwEQAh0ABwAAAGdldEJpZHMBEAIUAAUAAAAOAAAAdHJhY2tfdG9rZW5faWQdAAYAAABhbW91bnQKDQAAAG1vdG9fdG9rZW5faWQdAAkAAAB0aW1lc3RhbXAFBgAAAGJpZGRlchUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwUAAAAZ2V0RmluaXNoaW5nU2Vzc2lvbnMBEAIdAA4AAABnZXRMYXRlc3RQcmljZQEKGwAAAGdldE1vdG9kZXhNZXRhZGF0YUJ5VHlwZU5mdAIUAAEAAAAIAAAAdHlwZV9uZnQCFAAHAAAABAAAAG5hbWUWAgsAAABkZXNjcmlwdGlvbhYCCAAAAHR5cGVfbmZ0Ag4AAABjdXJyZW50X3N1cHBseQQKAAAAdHlwZV9saW1pdAQOAAAAdHlwZV9wcmljZV91c2QKAwAAAHVyaRYCEgAAAGdldFBlcmNlbnRGb3JUcmFjawIUAAEAAAAIAAAAdG9rZW5faWQdAAIPAAAAZ2V0UHJpY2VGb3JUeXBlAhQAAQAAAAgAAAB0eXBlX25mdAIKCwAAAGdldFNlc3Npb25zARACFAAMAAAADgAAAHRyYWNrX3Rva2VuX2lkHQAKAAAAdHJhY2tfdHlwZQIMAAAAdHJhY2tfaGVhbHRoCgkAAABpbml0X3RpbWUFDAAAAHBhcnRpY2lwYW50cxACFAAFAAAADQAAAG1vdG9fb3duZXJfaWQVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAG1vdG9fdG9rZW5faWQdAAkAAABtb3RvX3R5cGUCCwAAAG1vdG9faGVhbHRoChAAAABiZXN0X3RpbWVfcmVzdWx0BRIAAABsYXRlc3RfdXBkYXRlX3RpbWUFGAAAAGxhdGVzdF90cmFja190aW1lX3Jlc3VsdAUIAAAAYXR0ZW1wdHMCDQAAAGdhbWVfYmlkc19zdW0KDQAAAGdhbWVfZmVlc19zdW0KEwAAAGN1cnJlbnRfd2lubmVyX21vdG8VAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAUAAMAAAANAAAAbW90b19vd25lcl9pZBUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwNAAAAbW90b190b2tlbl9pZB0AFgAAAGxhc3RfdHJhY2tfdGltZV9yZXN1bHQODQAAAGVwb2NoX3BheW1lbnQQAhUEAAAABQAAAFRyYWNrAQEAAAAUAAQAAAAOAAAAdHJhY2tfdG9rZW5faWQdAAYAAABhbW91bnQKCwAAAHJlY2VpdmVyX2lkFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADA0AAABtb3RvX3Rva2VuX2lkFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAHQAEAAAATW90bwEBAAAAFAAEAAAADgAAAHRyYWNrX3Rva2VuX2lkHQAGAAAAYW1vdW50CgsAAAByZWNlaXZlcl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAABUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwNAAAAbW90b190b2tlbl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ABgAAAEJpZGRlcgEBAAAAFAAEAAAADgAAAHRyYWNrX3Rva2VuX2lkHQAGAAAAYW1vdW50CgsAAAByZWNlaXZlcl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAABUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwNAAAAbW90b190b2tlbl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ACAAAAFBsYXRmb3JtAAIAAAAGAAAAYW1vdW50Cg4AAAB0cmFja190b2tlbl9pZB0ADgAAAGdldFRva2VuSGVhbHRoAhQAAQAAAAgAAAB0b2tlbl9pZB0ACg0AAABnZXRUb2tlbk93bmVyAhQAAQAAAAgAAAB0b2tlbl9pZB0AFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADA4AAABnZXRUb2tlblR5cGVJZAIUAAEAAAAIAAAAdG9rZW5faWQdAAIPAAAAZ2V0VG9rZW5zSGVhbHRoARACDx0ACgQAAABtaW50BBQAAgAAAAUAAABvd25lchUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwGAAAAdG9rZW5zEQACFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CEgAAAG5mdFRva2Vuc0Zvck93bmVycwIUAAMAAAAHAAAAYWRkcmVzcxUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwKAAAAZnJvbV9pbmRleBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAAQFAAAAbGltaXQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAEEAIUAAMAAAAIAAAAdG9rZW5faWQdAAgAAABvd25lcl9pZBUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwIAAAAbWV0YWRhdGEUAAcAAAAEAAAAbmFtZRYCCwAAAGRlc2NyaXB0aW9uFgIIAAAAdHlwZV9uZnQCDgAAAGN1cnJlbnRfc3VwcGx5BAoAAAB0eXBlX2xpbWl0BA4AAAB0eXBlX3ByaWNlX3VzZAoDAAAAdXJpFgIKAAAAb3BlcmF0b3JPZgYQARQAAgAAAAUAAABvd25lchUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwHAAAAYWRkcmVzcxUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwQAQEVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIIAAAAcHVyY2hhc2UEFAACAAAACAAAAHJlZmVycmFsFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADAgAAAB0eXBlX25mdAIVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgINAAAAcHVyY2hhc2VCYXRjaAQUAAIAAAAIAAAAcmVmZXJyYWwVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAHR5cGVfbmZ0X2xpc3QQAgIVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIKAAAAcmV0dXJuTW90bwQUAAIAAAAIAAAAdG9rZW5faWQdAAkAAABuZXdfb3duZXIVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CCwAAAHJldHVyblRyYWNrBBQAAgAAAAgAAAB0b2tlbl9pZB0ACQAAAG5ld19vd25lchUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgINAAAAc2V0R2FtZVNlcnZlcgQUAAEAAAALAAAAZ2FtZV9zZXJ2ZXIVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CDgAAAHNldEhlYWx0aEZvcklkBBQAAgAAAAcAAAB0eXBlX2lkHQAFAAAAcHJpY2UFFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CDwAAAHNldEltcGxlbWVudG9ycwQUAAIAAAACAAAAaWQWAAwAAABpbXBsZW1lbnRvcnMQAgwVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgITAAAAc2V0TWluRXBvY2hJbnRlcnZhbAQUAAEAAAAIAAAAaW50ZXJ2YWwFFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CCQAAAHNldE1pbkZlZQQUAAEAAAAGAAAAYW1vdW50BRUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAhkAAABzZXRNaW5HYW1lU2Vzc2lvbkludGVydmFsBBQAAQAAAAgAAABpbnRlcnZhbAUVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgISAAAAc2V0UGVyY2VudEZvclRyYWNrBBQAAgAAAA4AAAB0cmFja190b2tlbl9pZB0ACgAAAHBlcmNlbnRhZ2UCFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CFwAAAHNldFBlcmNlbnRGb3JUcmFja093bmVyBBQAAgAAAA4AAAB0cmFja190b2tlbl9pZB0ACgAAAHBlcmNlbnRhZ2UCFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CDwAAAHNldFByaWNlRm9yVHlwZQQUAAIAAAAHAAAAdHlwZV9pZAIFAAAAcHJpY2UFFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CEwAAAHNldFByaWNlTWFpbkNvaW5Vc2QEFAABAAAABQAAAHByaWNlBRUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAggAAABzdXBwb3J0cwYQARYAEAEVAwAAAAkAAABOb1N1cHBvcnQCBwAAAFN1cHBvcnQCCQAAAFN1cHBvcnRCeQEBAAAAEAAMFQQAAAAOAAAASW52YWxpZFRva2VuSWQCEQAAAEluc3VmZmljaWVudEZ1bmRzAgwAAABVbmF1dGhvcml6ZWQCBgAAAEN1c3RvbQEBAAAAFRsAAAALAAAAUGFyc2VQYXJhbXMCBwAAAExvZ0Z1bGwCDAAAAExvZ01hbGZvcm1lZAIUAAAAVG9rZW5JZEFscmVhZHlFeGlzdHMCEwAAAEludm9rZUNvbnRyYWN0RXJyb3ICDQAAAFByaWNlTm90Rm91bmQCEgAAAFdyb25nUGF5bWVudEFtb3VudAIVAAAAUmVmZXJyYWxUcmFuc2ZlckVycm9yAg0AAABUcmFuc2ZlckVycm9yAgkAAABNYXRoRXJyb3ICDQAAAFdyb25nUmVmZXJyYWwCEwAAAFByaWNlTWFpbkNvaW5Jc1plcm8CDAAAAE5mdE5vdEV4aXN0cwIRAAAATmZ0TWlzbWF0Y2hlZFR5cGUCFgAAAE1hZ2ljQm94SXNOb3RTdXBwb3J0ZWQCEAAAAFplcm9Db3VudGVyRXJyb3ICCgAAAE5vdEFsbG93ZWQCEAAAAEdhbWVTZXNzaW9uRXJyb3ICDQAAAEdhbWVCaWRzRXJyb3ICEgAAAFRva2VuTm90T25Db250cmFjdAIVAAAAQmVsb3dNaW5FcG9jaEludGVydmFsAhcAAABJbmNvcnJlY3RTdGF0ZVBhcmFtZXRlcgABAAAACQAAAHBhcmFtZXRlchYCFwAAAE1vdG9kZXhNZXRhZGF0YU5vdEZvdW5kAhMAAABWaWV3Q29sbGVjdGlvbkVycm9yAAEAAAAEAAAAbmFtZRYCDwAAAFJhaXNlZFR5cGVMaW1pdAITAAAATW90b0ZlZUFtb3VudFRvb0xvdwIUAAAATW90b0hhc0FjdGl2ZVNlc3Npb24CCQAAAHN5bmNFcG9jaAYUAAEAAAAOAAAAdHJhY2tfdG9rZW5faWQdABQADAAAAA4AAAB0cmFja190b2tlbl9pZB0ACgAAAHRyYWNrX3R5cGUCDAAAAHRyYWNrX2hlYWx0aAoJAAAAaW5pdF90aW1lBQwAAABwYXJ0aWNpcGFudHMQAhQABQAAAA0AAABtb3RvX293bmVyX2lkFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADA0AAABtb3RvX3Rva2VuX2lkHQAJAAAAbW90b190eXBlAgsAAABtb3RvX2hlYWx0aAoQAAAAYmVzdF90aW1lX3Jlc3VsdAUSAAAAbGF0ZXN0X3VwZGF0ZV90aW1lBRgAAABsYXRlc3RfdHJhY2tfdGltZV9yZXN1bHQFCAAAAGF0dGVtcHRzAg0AAABnYW1lX2JpZHNfc3VtCg0AAABnYW1lX2ZlZXNfc3VtChMAAABjdXJyZW50X3dpbm5lcl9tb3RvFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAFAADAAAADQAAAG1vdG9fb3duZXJfaWQVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAG1vdG9fdG9rZW5faWQdABYAAABsYXN0X3RyYWNrX3RpbWVfcmVzdWx0Dg0AAABlcG9jaF9wYXltZW50EAIVBAAAAAUAAABUcmFjawEBAAAAFAAEAAAADgAAAHRyYWNrX3Rva2VuX2lkHQAGAAAAYW1vdW50CgsAAAByZWNlaXZlcl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAABUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwNAAAAbW90b190b2tlbl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ABAAAAE1vdG8BAQAAABQABAAAAA4AAAB0cmFja190b2tlbl9pZB0ABgAAAGFtb3VudAoLAAAAcmVjZWl2ZXJfaWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAG1vdG9fdG9rZW5faWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAdAAYAAABCaWRkZXIBAQAAABQABAAAAA4AAAB0cmFja190b2tlbl9pZB0ABgAAAGFtb3VudAoLAAAAcmVjZWl2ZXJfaWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAG1vdG9fdG9rZW5faWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAdAAgAAABQbGF0Zm9ybQACAAAABgAAAGFtb3VudAoOAAAAdHJhY2tfdG9rZW5faWQdABUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAhkAAABzeW5jRXBvY2hSZXN1bHRzQmlkc0ZpbmFsARACFAAFAAAADgAAAHRyYWNrX3Rva2VuX2lkHQANAAAAbW90b190b2tlbl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ABgAAAGFtb3VudAoCAAAAdG8VAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMDQAAAHJlY2VpdmVyX3R5cGUWAhoAAABzeW5jRXBvY2hSZXN1bHRzTW90b3NGaW5hbAEQAhQABQAAAA4AAAB0cmFja190b2tlbl9pZB0ADQAAAG1vdG9fdG9rZW5faWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAdAAYAAABhbW91bnQKAgAAAHRvFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADA0AAAByZWNlaXZlcl90eXBlFgIaAAAAc3luY0Vwb2NoUmVzdWx0c1RvdGFsRmluYWwBEAIUAAUAAAAOAAAAdHJhY2tfdG9rZW5faWQdAA0AAABtb3RvX3Rva2VuX2lkFQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAAHQAGAAAAYW1vdW50CgIAAAB0bxUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAABUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwNAAAAcmVjZWl2ZXJfdHlwZRYCEQAAAHRva2VuSWRzQW5kT3duZXJzAhQAAgAAAAoAAABmcm9tX2luZGV4FQIAAAAEAAAATm9uZQIEAAAAU29tZQEBAAAABAUAAABsaW1pdBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAAQQAhQABgAAAA4AAAB0cmFja190b2tlbl9pZBUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ACgAAAHRyYWNrX3R5cGUVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAACDQAAAG1vdG9fdG9rZW5faWQVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAAdAAkAAABtb3RvX3R5cGUVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAACCAAAAG93bmVyX2lkFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADA4AAABhY3RpdmVfc2Vzc2lvbhUCAAAABAAAAE5vbmUCBAAAAFNvbWUBAQAAAB0ADQAAAHRva2VuTWV0YWRhdGEGEAEdABABFAACAAAAAwAAAHVybBYBBAAAAGhhc2gVAgAAAAQAAABOb25lAgQAAABTb21lAQEAAAATIAAAAAIVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIIAAAAdHJhbnNmZXIEEAEUAAUAAAAIAAAAdG9rZW5faWQdAAYAAABhbW91bnQbJQAAAAQAAABmcm9tFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADAIAAAB0bxUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAgAAAAwWAQQAAABkYXRhHQEVBAAAAA4AAABJbnZhbGlkVG9rZW5JZAIRAAAASW5zdWZmaWNpZW50RnVuZHMCDAAAAFVuYXV0aG9yaXplZAIGAAAAQ3VzdG9tAQEAAAAVGwAAAAsAAABQYXJzZVBhcmFtcwIHAAAATG9nRnVsbAIMAAAATG9nTWFsZm9ybWVkAhQAAABUb2tlbklkQWxyZWFkeUV4aXN0cwITAAAASW52b2tlQ29udHJhY3RFcnJvcgINAAAAUHJpY2VOb3RGb3VuZAISAAAAV3JvbmdQYXltZW50QW1vdW50AhUAAABSZWZlcnJhbFRyYW5zZmVyRXJyb3ICDQAAAFRyYW5zZmVyRXJyb3ICCQAAAE1hdGhFcnJvcgINAAAAV3JvbmdSZWZlcnJhbAITAAAAUHJpY2VNYWluQ29pbklzWmVybwIMAAAATmZ0Tm90RXhpc3RzAhEAAABOZnRNaXNtYXRjaGVkVHlwZQIWAAAATWFnaWNCb3hJc05vdFN1cHBvcnRlZAIQAAAAWmVyb0NvdW50ZXJFcnJvcgIKAAAATm90QWxsb3dlZAIQAAAAR2FtZVNlc3Npb25FcnJvcgINAAAAR2FtZUJpZHNFcnJvcgISAAAAVG9rZW5Ob3RPbkNvbnRyYWN0AhUAAABCZWxvd01pbkVwb2NoSW50ZXJ2YWwCFwAAAEluY29ycmVjdFN0YXRlUGFyYW1ldGVyAAEAAAAJAAAAcGFyYW1ldGVyFgIXAAAATW90b2RleE1ldGFkYXRhTm90Rm91bmQCEwAAAFZpZXdDb2xsZWN0aW9uRXJyb3IAAQAAAAQAAABuYW1lFgIPAAAAUmFpc2VkVHlwZUxpbWl0AhMAAABNb3RvRmVlQW1vdW50VG9vTG93AhQAAABNb3RvSGFzQWN0aXZlU2Vzc2lvbgIOAAAAdXBkYXRlT3BlcmF0b3IEEAEUAAIAAAAGAAAAdXBkYXRlFQIAAAAGAAAAUmVtb3ZlAgMAAABBZGQCCAAAAG9wZXJhdG9yFQIAAAAHAAAAQWNjb3VudAEBAAAACwgAAABDb250cmFjdAEBAAAADBUEAAAADgAAAEludmFsaWRUb2tlbklkAhEAAABJbnN1ZmZpY2llbnRGdW5kcwIMAAAAVW5hdXRob3JpemVkAgYAAABDdXN0b20BAQAAABUbAAAACwAAAFBhcnNlUGFyYW1zAgcAAABMb2dGdWxsAgwAAABMb2dNYWxmb3JtZWQCFAAAAFRva2VuSWRBbHJlYWR5RXhpc3RzAhMAAABJbnZva2VDb250cmFjdEVycm9yAg0AAABQcmljZU5vdEZvdW5kAhIAAABXcm9uZ1BheW1lbnRBbW91bnQCFQAAAFJlZmVycmFsVHJhbnNmZXJFcnJvcgINAAAAVHJhbnNmZXJFcnJvcgIJAAAATWF0aEVycm9yAg0AAABXcm9uZ1JlZmVycmFsAhMAAABQcmljZU1haW5Db2luSXNaZXJvAgwAAABOZnROb3RFeGlzdHMCEQAAAE5mdE1pc21hdGNoZWRUeXBlAhYAAABNYWdpY0JveElzTm90U3VwcG9ydGVkAhAAAABaZXJvQ291bnRlckVycm9yAgoAAABOb3RBbGxvd2VkAhAAAABHYW1lU2Vzc2lvbkVycm9yAg0AAABHYW1lQmlkc0Vycm9yAhIAAABUb2tlbk5vdE9uQ29udHJhY3QCFQAAAEJlbG93TWluRXBvY2hJbnRlcnZhbAIXAAAASW5jb3JyZWN0U3RhdGVQYXJhbWV0ZXIAAQAAAAkAAABwYXJhbWV0ZXIWAhcAAABNb3RvZGV4TWV0YWRhdGFOb3RGb3VuZAITAAAAVmlld0NvbGxlY3Rpb25FcnJvcgABAAAABAAAAG5hbWUWAg8AAABSYWlzZWRUeXBlTGltaXQCEwAAAE1vdG9GZWVBbW91bnRUb29Mb3cCFAAAAE1vdG9IYXNBY3RpdmVTZXNzaW9uAg8AAAB2YWx1ZUluTWFpbkNvaW4CFAABAAAACAAAAHR5cGVfbmZ0AgoEAAAAdmlldwEUAAkAAAAFAAAAc3RhdGUQAg8VAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMFAACAAAADAAAAG93bmVkX3Rva2VucxACHQAJAAAAb3BlcmF0b3JzEAIVAgAAAAcAAABBY2NvdW50AQEAAAALCAAAAENvbnRyYWN0AQEAAAAMCgAAAGFsbF90b2tlbnMQAg8dABUCAAAABwAAAEFjY291bnQBAQAAAAsIAAAAQ29udHJhY3QBAQAAAAwHAAAAbWluX2ZlZQULAAAAbWluX2ZlZV91c2QFEgAAAG1pbl9lcG9jaF9pbnRlcnZhbAUTAAAAbGF0ZXN0X2Vwb2NoX3VwZGF0ZQUZAAAAbWluX2dhbWVfc2Vzc2lvbl9kdXJhdGlvbgUTAAAAcHJpY2VfbWFpbl9jb2luX3VzZAUHAAAAY291bnRlcgQA';


// will be defined after connect()
let provider;
let web3;

/*
paste this in inspector to connect to wallet:
window.web3gl.connect()
*/

let walletAddress;

async function connect() {

    console.log("connect window.web3ChainId " + window.web3ChainId);
    if (window.web3ChainId == 111111456327825 || window.web3ChainId == 111111456327830)
    {
        await import('./loader_icp.js')

        if (window.web3ChainId == 111111456327830){
            console.log("ICP Mainnet");

        }
        else{
            console.log("ICP Testnet");

        }
        const canisterIdinternetIdentity = 'rdmx6-jaaaa-aaaaa-aaadq-cai'
        while (window.ICPauthClient === undefined) {
            await sleep(2000);
            console.log("window.ICPauthClient === ",window.ICPauthClient)
        }
        console.log("1 window.ICPauthClient === ",window.ICPauthClient)

        // setTimeout(async()=> {
        window.ICPauthClient.login({

            identityProvider: (window.web3ChainId) == 111111456327830 ? "https://identity.ic0.app/#authorize" :'http://' + canisterIdinternetIdentity + '.localhost:4943',
            // 7 days in nanoseconds
            maxTimeToLive: BigInt(7 * 24 * 60 * 60 * 1000 * 1000 * 1000),

            onSuccess: async () => {
                console.log("success")


                const identity = await window.ICPauthClient.getIdentity();
                console.log("identity " + JSON.stringify(identity))

                const principal = await identity.getPrincipal()
                console.log("getPrincipal " + principal)
                setTimeout(async()=>console.log(await window.navigator.clipboard.writeText(principal.toString())), 3000)

                const accId = (await window.AccountIdentifier.fromPrincipal({principal})).toHex()
                console.log("accId " + JSON.stringify(accId))
                web3gl.connectAccount = principal.toString();
                window.identityICP = identity;

                console.log("web3gl.connectAccount " + web3gl.connectAccount)

                return;

//                 const host = 'local' === 'local' ? 'http://127.0.0.1:4943' : 'https://icp-api.io';
//
//                 const agent = new window.HttpAgent({
//                     identity,
//                     host ,
//                 });
//                 await agent.fetchRootKey()
//
//                 const a = window.Actor.createActor(window.idlFactoryMotodex, {
//                     agent,
//                     canisterId
//                 });
//                 let get_counter = await a.get_counter();
//                 console.log("2 get_counter " + get_counter)
//
//                 const res = await a.update_counter()
//                 console.log("update_counter  res " + JSON.stringify(res))
//
//                 get_counter = await a.get_counter();
//                 console.log("3 get_counter " + get_counter)
//
//                 const aICP = window.Actor.createActor(window.idlFactoryICP, {
//                     agent,
//                     canisterId: "ryjl3-tyaaa-aaaaa-aaaba-cai"
//                 });
//                 const decimals = await aICP.decimals();
//                 console.log("1 decimals " + JSON.stringify(decimals))
//
//                 const icrc1_balance_of = await aICP.icrc1_balance_of({owner:principal, subaccount:[]});
//
//                 function stringFrom(object) {
//                     return JSON.stringify(object, (key, value) =>
//                         typeof value === 'bigint'
//                             ? value.toString()
//                             : value // return everything else unchanged
//                     );
//                 }
//
//                 console.log("1 icrc1_balance_of " + JSON.stringify(stringFrom(icrc1_balance_of)))
//                 const motoDEXprincipal = window.Principal.fromText('be2us-64aaa-aaaaa-qaabq-cai')
// // Call the icrc2_approve() function
//                 const approveArgs = {
//                     fee: [],
//                     memo: [],
//                     from_subaccount: [],
//                     created_at_time: [],
//                     amount: 500_000_000,
//                     expected_allowance: [],
//                     expires_at: [],
//                     spender: {
//                         owner: motoDEXprincipal, //i also tried the canisterId of the canister i launched
//                         subaccount: [],
//                     },
//                 };
//
//                 const icrc2_approve = await aICP.icrc2_approve(approveArgs);
//                 console.log(" icrc2_approve " + JSON.stringify(stringFrom(icrc2_approve)))
//                 if (icrc2_approve.Ok) {
//                     console.log('Approve successful, transaction ID:', icrc2_approve.Ok);
//                 } else {
//                     console.error('Approve failed:', icrc2_approve.Err);
//                 }
//
//
//                 const purchase = await a.purchase(0);
//                 if (purchase.Ok) {
//                     console.log('purchase successful, token ID:', purchase.Ok);
//                 } else {
//                     console.error('purchase failed:', purchase.Err);
//                 }

                // console.log(" purchase " + JSON.stringify(stringFrom(purchase)))

            },
            onError: async () => {
                web3gl.connectAccount = "fail";
                return
            }
        });
        // }, 3000)
        return;
    }

    if (window.web3ChainId == 1111111456327825 || window.web3ChainId == 1111111456327830)
    {
        await import('./loader_nibiru.js')
        if (!window.getOfflineSigner || !window.keplr) {
            alert("Please install Keplr extension");
            return;
        }
        let chainInfo = window.nibiruChainInfoTestnet
        if (window.web3ChainId == 1111111456327830){
            console.log("NIBIRU Mainnet");
            chainInfo = window.nibiruChainInfoMainnet;
        }
        else{
            console.log("NIBIRU Testnet");
        }
        window.nibiruChainInfo = chainInfo
        await window.keplr.experimentalSuggestChain(chainInfo);
        // Enable Keplr
        await window.keplr.enable(chainInfo.chainId);
        // Get the offline signer from Keplr
        const offlineSigner = window.getOfflineSigner(chainInfo.chainId);
        const accounts = await offlineSigner.getAccounts();
        console.log("accounts",JSON.stringify(accounts));
        web3gl.connectAccount = accounts[0].address;
        web3gl.nibiruAccount = accounts[0].address;
        const script = document.createElement("script");
        script.src = "https://cdn.jsdelivr.net/npm/@nibiruchain/nibijs";
        script.onload = async () => {
            // const contractAddress = "nibi1tnce5ynlucdml9h8nl7aefa04097qtl8nejhuexz90t6pxp3xwwsuu2ud4"

            // Use CosmJS once it's loaded
            eval(script.textContent); // Evaluate the loaded script
            // const client = await StargateClient.connect(chainInfo.rpc);

            const signingClient =
                await window.SigningStargateClient.connectWithSigner(
                    chainInfo.rpc,
                    offlineSigner,
                );
            window.signingClient = signingClient

            const wasmClient = await window.SigningCosmWasmClient.connectWithSigner(
                chainInfo.rpc,
                offlineSigner,
                {gasPrice: window.GasPrice.fromString("25000unibi")}
            );
            window.wasmClient = wasmClient

        };
        document.head.appendChild(script);

        return;
    }

    if (window.web3ChainId == 1111456327825 || window.web3ChainId == 1111456327830)
    {
        await import('./loader_vara.js')

        // if (window.web3ChainId == 1111456327830){
        //     console.log("VARA Mainnet");
        // } else {
        window.web3ChainId == 1111456327825 ? console.log("VARA Testnet") : console.log("VARA Mainnet");
        const extensions = await window.web3Enable('motoDEX');
        const accounts = await window.web3Accounts({
        });
        if (extensions.length === 0) {
            // no extension installed, or the user did not accept the authorization
            // in this case we should inform the use and give a link to the extension
            alert('VARA extension installed, or the user did not accept the authorization ')

            return;
        }

        if (accounts.length === 0) {
            alert('VARA No accounts connected')
            web3gl.connectAccount = "fail";
            return
        }
        window.varaAccounts = accounts;
        console.log('accounts:', JSON.stringify(accounts))
        web3gl.connectAccount = accounts[0].address;

        window.varaConnectAccount = accounts[0].address;
        // }
        return;
    }

    if (window.web3ChainId == 11111456327825 || window.web3ChainId == 11111456327830)
    {
        await import('./loader_sui.js')
        let wallets = window.getWallets().get();

        if (window.web3ChainId == 11111456327830){
            console.log("sui Mainnet");

        }
        else{
            console.log("sui Testnet");

        }
        try
        {
            if (wallets.length > 0) {
                // let finalWallet
                // let otherWallet
                // wallets.forEach(wallet => {
                //     if (wallet.name === 'Sui Wallet') finalWallet = wallet
                //     else otherWallet = wallet
                // })
                // if (finalWallet === undefined) finalWallet = otherWallet
                // const res = await finalWallet.features["standard:connect"].connect();
                // const account = res.accounts[0]
                // web3gl.suiFinalWallet = finalWallet
                const account = await window.martian.sui.connect(['viewAccount', 'suggestTransactions']);
                await window.martian.sui.isConnected()
                web3gl.connectAccount = account.address;
                window.suiWalletAddress = account.address;
            } else {
                window.open("https://www.martianwallet.xyz/", "_blank").focus();
            }
            // if ("martian" in window) {
            //     // Permissions: ['viewAccount', 'suggestTransactions']
            //     const account = await window.martian.sui.connect(['viewAccount', 'suggestTransactions']);
            //     await window.martian.sui.isConnected()
            //     web3gl.connectAccount = account.address;
            //     window.suiWalletAddress = account.address;
            // } else {
            //     window.open("https://www.martianwallet.xyz/", "_blank").focus();
            // }
        }
        catch(error)
        {
            web3gl.connectAccount = "fail";
        }
        return;
    }

    if (window.web3ChainId == 111456327825 || window.web3ChainId == 111456327830)
    {
        await import('./loader_aptos.js')

        if (window.web3ChainId == 111456327830){
            console.log("aptos Mainnet");

        }
        else{
            console.log("Aptos Testnet");
            try
            {
                await window.petraWallet.connect();
                const account = await window.petraWallet.account();
                web3gl.connectAccount = account.address;
                window.aptosWalletAddress = account.address;
            }
            catch(error)
            {
                web3gl.connectAccount = "fail";
            }
        }
        return;
    }
    if (window.web3ChainId == 1456327825 || window.web3ChainId == 1456327830)
    {
        document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "//unpkg.com/@concordium/browser-wallet-api-helpers@2.4.0/lib/concordiumHelpers.min.js" }));
        document.body.appendChild(Object.assign(document.createElement("script"), { type: "text/javascript", src: "//unpkg.com/@concordium/web-sdk@3.4.1/lib/concordium.min.js" }));

        if (window.web3ChainId == 1456327830){
            console.log("CCD Mainnet");
            bin64 = mainCCDBin64;
            web3gl.connectAccount = await connectConcordiumWallet(true);
        }
        else{
            console.log("CCD Test");
            bin64 = testCCDBin64;
            web3gl.connectAccount = await connectConcordiumWallet(false);
        }
        return;
    }
    if (window.web3ChainId == 11456327825 || window.web3ChainId == 11456327830)
    {
        await import('./loader_az.js')

        if (window.web3ChainId == 11456327830){
            console.log("AZ Mainnet");
            // web3gl.connectAccount = await connectConcordiumWallet(true);
        }
        else{
            console.log("AZ Test");
            await window.web3Enable('motoDEX');
            const accounts = await window.web3Accounts({
                extensions: ["aleph-zero-signer"],
                genesisHash:
                    "0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e",
            });
            if (accounts.length === 0) {
                alert('No accounts connected')
                web3gl.connectAccount = "fail";
                return
            }
            window.azAccounts = accounts;
            console.log('accounts:', JSON.stringify(accounts))
            web3gl.connectAccount = accounts[0].address;
            window.azConnectAccount = accounts[0].address;
            // window.web3Enable('motoDEX')
            // 		.then(() => {
            // 			console.log('enabled', true);
            //
            // 			return window.web3Accounts({
            // 				extensions: ["aleph-zero-signer"],
            // 				genesisHash:
            // 						"0x05d5279c52c484cc80396535a316add7d47b1c5b9e0398dd1f584149341460c5",
            // 			});
            // 		})
            // 		.then((accounts) => {
            //
            // 					console.log('accounts:', JSON.stringify(accounts))
            // 				}
            // 		);
            // web3gl.connectAccount =
        }
        return;
    }

    await import('./loader_wc.js')
    
    await initializeWeb3Modal();

    console.log('connect walletAddress', walletAddress);
    console.log('connect window.web3modal', window.web3modal);
    console.log('connect window.web3modal.subscribe', window.web3modal.subscribeModal);

    console.log('connect walletAddress', walletAddress === undefined);
    console.log('connect window.web3modal', window.web3modal !== undefined);
    console.log('connect window.web3modal.subscribe', window.web3modal.subscribeModal !== undefined);
    
    if (walletAddress === undefined && window.web3modal !== undefined && window.web3modal.subscribeModal !== undefined) window.web3modal.subscribeModal(async (newState) => {
        console.log('connect newState->', newState)
        const account = window.getAccount()
        console.log('2 connect account->',account)
        const network = getNetwork()
        console.log('connect network->',network)
        console.log('connect web3gl.networkId->',web3gl.networkId)
        if (network !== undefined && network.chain !== undefined) console.log('connect network.chain.id->',network.chain.id)

        walletAddress = account.address
        if (walletAddress === undefined) {
            if (newState.open == false) {
                web3gl.connectAccount = "fail";
                return
            }
        } else {
            web3gl.networkId =  parseInt(network.chain.id + '')
            web3gl.connectAccount = walletAddress

            if (web3gl.networkId !== window.web3ChainId) {
                console.log("networkId empty wallet - ", web3gl.networkId);
                console.log("chainId empty wallet- ", window.web3ChainId);
                (async () => {
                    try {
                        await switchToCorrectNetwork();
                        console.log("Network switch completed empty wallet");
                    } catch (error) {
                        console.error("Error switching network empty wallet:", error);
                    }
                })();
            } 
            return
            //window.location.reload();
        }
    })
    
    const account = window.getAccount();
    if (account.address !== undefined){
        console.log("open modal in the second");

        // await web3modal.openModal()
        const subscriptionCallback = async (newState) => {

            console.log('2 connect account->', account);
            const network = getNetwork();
            console.log('2 connect network->', network);
            if (network !== undefined && network.chain !== undefined) {
                console.log('3 connect network->', network);

                (async () => {
                    console.log('4 connect network->', network);
                    web3gl.networkId = parseInt(network.chain.id + '');
                    walletAddress = account.address;
                    web3gl.connectAccount = walletAddress;
                    if (web3gl.networkId !== window.web3ChainId) {
                        console.log("networkId - ", web3gl.networkId);
                        console.log("chainId - ", window.web3ChainId);
                        try {
                            await switchToCorrectNetwork();
                            console.log("Network switch completed");
                        } catch (error) {
                            console.error("Error switching network:", error);
                        }
                    }
                })();
            }
        };
        try {
            window.web3modal.subscribeModal(subscriptionCallback);
            console.log('Subscription set up successfully');

            await subscriptionCallback({open: true});
        } catch (error) {
            console.error('Error setting up or triggering subscription:', error);
        }
    }
    else {
        console.log("open modal")
        await web3modal.openModal()
    }

    return;
    
    console.log("after return");
    // uncomment to enable torus and walletconnect
    const providerOptions = {
        // torus: {
        //   package: Torus,
        // },
        walletconnect: {
            package: window.WalletConnectProvider.default,
            options: {
                infuraId: "635e974724fe49ca9b3414a63e5ac5d2",
                rpc: {
                    137: 'https://polygon-rpc.com',
                },
                // chainId: "137",
                network: "matic",
                qrcode: true,
                qrcodeModalOptions: {
                    mobileLinks: [
                        "metamask",
                        "trust",
                    ]
                }
            },
        },
        "custom-safepalwallet": {
            display: {
                logo: "https://www.safepal.com/assets/img/newlook/SafePal-full-logo.svg",
                //logo: "https://drive.google.com/uc?export=view&id=1CfTX6AsRfzMa_1zhmavWXoe6jVmHSzM8",
                //downloadableLogo: "https://drive.google.com/u/0/uc?id=1CfTX6AsRfzMa_1zhmavWXoe6jVmHSzM8&export=download",
                name: "SafePal",
                description: "Connect to your SafePal Wallet"
            },
            package: true,
            connector: async () => {
                let provider = null;
                if (typeof window.ethereum !== 'undefined') {
                    provider = window.ethereum;
                    try {
                        await provider.request({ method: 'eth_requestAccounts' })
                    } catch (error) {
                        throw new Error("User Rejected");
                    }
                } else {
                    throw new Error("No SafePal Wallet found");
                }
                return provider;
            }
        }
        // "custom-okx": {
        //      display: {
        //      logo: "https://static.coinall.ltd/cdn/zendesk/theme.zdassets.com/theme_assets/2040249/1d1ade3504c300c9020e79e00515247db969b7bc.png",
        //      name: "OKX",
        //      description: "Connect to OKX Wallet"
        //    },
        //    package: true,
        //    connector: async () => {
        //      let provider = null;
        //      if (typeof window.ethereum !== 'undefined') {
        //        provider = window.ethereum;
        //        try {
        //          await provider.request({ method: 'eth_requestAccounts' })
        //        } catch (error) {
        //          throw new Error("User Rejected");
        //        }
        //      } else {
        //        throw new Error("No SafePal Wallet found");
        //      }
        //      return provider;
        //    }
        //  }
        //    "custom-polygon": {
        //     display: {
        //         logo: "https://polygon.technology/wp-content/uploads/2021/07/polygon-logo.svg",
        //         name: "WalletConnect Polygon",
        //         description: "Connect to your Wallet with Wallet connect"
        //     },
        //     package: WalletConnectProvider,
        //     options: {
        //         // Mikko's test key - don't copy as your mileage may vary
        //         //infuraId: "bb7b522604e54a2f8ad251e7417b2355",
        //         rpc: {
        //             137: 'https://matic-mainnet.chainstacklabs.com'
        //         },
        //         chainId: 137,
        //         network: "polygon",
        //         qrcode: true,
        //         qrcodeModalOptions: {
        //             mobileLinks: [
        //                 "metamask",
        //                 "trust",
        //             ]
        //         }
        //     }
        // },
    };

    const web3Modal = new window.Web3Modal.default({
        providerOptions,
    });

    web3Modal.clearCachedProvider();

    // set provider
    provider = await web3Modal.connect();
    web3 = new Web3(provider);

    // set current network id
    web3gl.networkId = parseInt(provider.chainId);

    // if current network id is not equal to network id, then switch
    if (web3gl.networkId != window.web3ChainId) {
        await window.ethereum
            .request({
                method: "wallet_switchEthereumChain",
                params: [{ chainId: `0x${window.web3ChainId.toString(16)}` }], // chainId must be in hexadecimal numbers
            })
            .catch(() => {
                addNetwork(window.web3ChainId);
                //window.location.reload();
            });
    }

    // if the current network is still not equal to the network id, then return and stop the connection
    if (web3gl.networkId != window.web3ChainId) {
        web3gl.connectAccount = "fail";
        return;
    }

    // set current account
    if (provider.selectedAddress !== undefined) web3gl.connectAccount = provider.selectedAddress;
    else web3gl.connectAccount = provider.accounts[0];

    // refresh page if player changes account
    provider.on("accountsChanged", (accounts) => {
        window.location.reload();
    });

    // update if player changes network
    provider.on("chainChanged", (chainId) => {
        web3gl.networkId = parseInt(chainId);
    });
}

/*
paste this in inspector to connect to sign message:
window.web3gl.signMessage("hello")
*/
async function signMessage(message) {
    try {
        const from = (await web3.eth.getAccounts())[0];
        const signature = await web3.eth.personal.sign(message, from, "");
        window.web3gl.signMessageResponse = signature;
    } catch (error) {
        window.web3gl.signMessageResponse = error.message;
    }
}

/*
paste this in inspector to send eth:
const to = "0xdD4c825203f97984e7867F11eeCc813A036089D1"
const value = "12300000000000000"
const gasLimit = "21000" // gas limit
const gasPrice = "33333333333"
window.web3gl.sendTransaction(to, value, gasLimit, gasPrice);
*/
async function sendTransaction(to, value, gasLimit, gasPrice) {
    const from = (await web3.eth.getAccounts())[0];
    web3.eth
        .sendTransaction({
            from,
            to,
            value,
            gas: gasLimit ? gasLimit : undefined,
            gasPrice: gasPrice ? gasPrice : undefined,
        })
        .on("transactionHash", (transactionHash) => {
            window.web3gl.sendTransactionResponse = transactionHash;
        })
        .on("error", (error) => {
            window.web3gl.sendTransactionResponse = error.message;
        });
}

/*
paste this in inspector to connect to interact with contract:
const method = "increment"
const abi = `[ { "inputs": [], "name": "increment", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "x", "outputs": [ { "internalType": "uint256", "name": "", "type": "uint256" } ], "stateMutability": "view", "type": "function" } ]`;
const contract = "0xB6B8bB1e16A6F73f7078108538979336B9B7341C"
const args = "[]"
const value = "0"
const gasLimit = "222222" // gas limit
const gasPrice = "333333333333"
window.web3gl.sendContract(method, abi, contract, args, value, gasLimit, gasPrice)
*/
function toJson(data) {
    if (data !== undefined) {
        return JSON.stringify(data, (_, v) => typeof v === 'bigint' ? `${v}#bigint` : v)
            .replace(/"(-?\d+)#bigint"/g, (_, a) => a);
    }
}

let busdABI = '[{"inputs":[{"internalType":"uint256","name":"_initialAmount","type":"uint256"},{"internalType":"string","name":"_tokenName","type":"string"},{"internalType":"uint8","name":"_decimalUnits","type":"uint8"},{"internalType":"string","name":"_tokenSymbol","type":"string"}],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"constant":false,"inputs":[{"internalType":"address","name":"_owner","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"allocateTo","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"_spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"dst","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"src","type":"address"},{"internalType":"address","name":"dst","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"}]'
let usdcABI = '[{"type":"event","name":"Approval","inputs":[{"type":"address","name":"owner","internalType":"address","indexed":true},{"type":"address","name":"spender","internalType":"address","indexed":true},{"type":"uint256","name":"value","internalType":"uint256","indexed":false}],"anonymous":false},{"type":"event","name":"RoleAdminChanged","inputs":[{"type":"bytes32","name":"role","internalType":"bytes32","indexed":true},{"type":"bytes32","name":"previousAdminRole","internalType":"bytes32","indexed":true},{"type":"bytes32","name":"newAdminRole","internalType":"bytes32","indexed":true}],"anonymous":false},{"type":"event","name":"RoleGranted","inputs":[{"type":"bytes32","name":"role","internalType":"bytes32","indexed":true},{"type":"address","name":"account","internalType":"address","indexed":true},{"type":"address","name":"sender","internalType":"address","indexed":true}],"anonymous":false},{"type":"event","name":"RoleRevoked","inputs":[{"type":"bytes32","name":"role","internalType":"bytes32","indexed":true},{"type":"address","name":"account","internalType":"address","indexed":true},{"type":"address","name":"sender","internalType":"address","indexed":true}],"anonymous":false},{"type":"event","name":"Transfer","inputs":[{"type":"address","name":"from","internalType":"address","indexed":true},{"type":"address","name":"to","internalType":"address","indexed":true},{"type":"uint256","name":"value","internalType":"uint256","indexed":false}],"anonymous":false},{"type":"function","stateMutability":"view","outputs":[{"type":"bytes32","name":"","internalType":"bytes32"}],"name":"BURNER_ROLE","inputs":[]},{"type":"function","stateMutability":"view","outputs":[{"type":"bytes32","name":"","internalType":"bytes32"}],"name":"DEFAULT_ADMIN_ROLE","inputs":[]},{"type":"function","stateMutability":"view","outputs":[{"type":"bytes32","name":"","internalType":"bytes32"}],"name":"MINTER_ROLE","inputs":[]},{"type":"function","stateMutability":"view","outputs":[{"type":"uint256","name":"","internalType":"uint256"}],"name":"allowance","inputs":[{"type":"address","name":"owner","internalType":"address"},{"type":"address","name":"spender","internalType":"address"}]},{"type":"function","stateMutability":"nonpayable","outputs":[{"type":"bool","name":"","internalType":"bool"}],"name":"approve","inputs":[{"type":"address","name":"spender","internalType":"address"},{"type":"uint256","name":"amount","internalType":"uint256"}]},{"type":"function","stateMutability":"view","outputs":[{"type":"uint256","name":"","internalType":"uint256"}],"name":"balanceOf","inputs":[{"type":"address","name":"account","internalType":"address"}]},{"type":"function","stateMutability":"nonpayable","outputs":[],"name":"burn","inputs":[{"type":"uint256","name":"amount","internalType":"uint256"}]},{"type":"function","stateMutability":"view","outputs":[{"type":"uint8","name":"","internalType":"uint8"}],"name":"decimals","inputs":[]},{"type":"function","stateMutability":"nonpayable","outputs":[{"type":"bool","name":"","internalType":"bool"}],"name":"decreaseAllowance","inputs":[{"type":"address","name":"spender","internalType":"address"},{"type":"uint256","name":"subtractedValue","internalType":"uint256"}]},{"type":"function","stateMutability":"view","outputs":[{"type":"bytes32","name":"","internalType":"bytes32"}],"name":"getRoleAdmin","inputs":[{"type":"bytes32","name":"role","internalType":"bytes32"}]},{"type":"function","stateMutability":"nonpayable","outputs":[],"name":"grantRole","inputs":[{"type":"bytes32","name":"role","internalType":"bytes32"},{"type":"address","name":"account","internalType":"address"}]},{"type":"function","stateMutability":"view","outputs":[{"type":"bool","name":"","internalType":"bool"}],"name":"hasRole","inputs":[{"type":"bytes32","name":"role","internalType":"bytes32"},{"type":"address","name":"account","internalType":"address"}]},{"type":"function","stateMutability":"nonpayable","outputs":[{"type":"bool","name":"","internalType":"bool"}],"name":"increaseAllowance","inputs":[{"type":"address","name":"spender","internalType":"address"},{"type":"uint256","name":"addedValue","internalType":"uint256"}]},{"type":"function","stateMutability":"nonpayable","outputs":[],"name":"mint","inputs":[{"type":"address","name":"to","internalType":"address"},{"type":"uint256","name":"amount","internalType":"uint256"}]},{"type":"function","stateMutability":"view","outputs":[{"type":"string","name":"","internalType":"string"}],"name":"name","inputs":[]},{"type":"function","stateMutability":"nonpayable","outputs":[],"name":"renounceRole","inputs":[{"type":"bytes32","name":"role","internalType":"bytes32"},{"type":"address","name":"account","internalType":"address"}]},{"type":"function","stateMutability":"nonpayable","outputs":[],"name":"revokeRole","inputs":[{"type":"bytes32","name":"role","internalType":"bytes32"},{"type":"address","name":"account","internalType":"address"}]},{"type":"function","stateMutability":"view","outputs":[{"type":"bool","name":"","internalType":"bool"}],"name":"supportsInterface","inputs":[{"type":"bytes4","name":"interfaceId","internalType":"bytes4"}]},{"type":"function","stateMutability":"view","outputs":[{"type":"string","name":"","internalType":"string"}],"name":"symbol","inputs":[]},{"type":"function","stateMutability":"view","outputs":[{"type":"uint256","name":"","internalType":"uint256"}],"name":"totalSupply","inputs":[]},{"type":"function","stateMutability":"nonpayable","outputs":[{"type":"bool","name":"","internalType":"bool"}],"name":"transfer","inputs":[{"type":"address","name":"to","internalType":"address"},{"type":"uint256","name":"amount","internalType":"uint256"}]},{"type":"function","stateMutability":"nonpayable","outputs":[{"type":"bool","name":"","internalType":"bool"}],"name":"transferFrom","inputs":[{"type":"address","name":"from","internalType":"address"},{"type":"address","name":"to","internalType":"address"},{"type":"uint256","name":"amount","internalType":"uint256"}]}]'
async function sendContract(method, abi, contract, args, value, gasLimit, gasPrice) {
    console.log("sendContract method - " + method);

    if (method == "purchase")
    {
        googleAnalyticsSendEvent("purchase_nft");
    }
    if (window.web3ChainId == 1111111456327825 || window.web3ChainId == 1111111456327830)
    {
        let nibiruResponse = await nibiruSendContract(contract, method, args, value);
        console.log("sendContract nibiruResponse" + nibiruResponse);
        // console.log(typeof concResponse);
        if (typeof nibiruResponse != "string" || nibiruResponse.length == 0)
        {
            window.web3gl.sendContractResponse = JSON.stringify(nibiruResponse);
        }
        else
        {
            window.web3gl.sendContractResponse = nibiruResponse;
        }
        console.log("sendContract window.web3gl.sendContractResponse" + window.web3gl.sendContractResponse);
        return;
    }
    if (window.web3ChainId == 1111456327825 || window.web3ChainId == 1111456327830)
    {
        let azResponse = await varaSendContract(contract, method, args, value);
        if ( azResponse == "received" ) azResponse = {"transactionHash": "0x8e6535d88481117c1f0a32ba8f9bffefe32047dce3e2138eb87f6ab15662b047"};
        console.log("sendContract azResponse" + azResponse);
        // console.log(typeof concResponse);
        if (typeof azResponse != "string" || azResponse.length == 0)
        {
            window.web3gl.sendContractResponse = JSON.stringify(azResponse);
        }
        else
        {
            window.web3gl.sendContractResponse = azResponse;
        }
        console.log(window.web3gl.sendContractResponse);
        return;
    }
    if (window.web3ChainId == 11111456327825 || window.web3ChainId == 11111456327830)
    {
        let suiResponse = await suiSendContract(contract, method, args, value);
        console.log("sendContract suiResponse" + suiResponse);
        // console.log(typeof concResponse);
        if (typeof suiResponse != "string" || suiResponse.length == 0)
        {
            window.web3gl.sendContractResponse = JSON.stringify(suiResponse);
        }
        else
        {
            window.web3gl.sendContractResponse = suiResponse;
        }
        console.log("sendContract window.web3gl.sendContractResponse" + window.web3gl.sendContractResponse);
        return;
    }
    if (window.web3ChainId == 111111456327825 || window.web3ChainId == 111111456327830)
    {
        let icpResponse = await icpSendContract(contract, method, args, value);
        console.log("sendContract icpResponse" + icpResponse);
        // console.log(typeof concResponse);
        if (typeof icpResponse != "string" || icpResponse.length == 0)
        {
            window.web3gl.sendContractResponse = JSON.stringify(icpResponse);
        }
        else
        {
            window.web3gl.sendContractResponse = icpResponse;
        }
        console.log("sendContract window.web3gl.sendContractResponse" + window.web3gl.sendContractResponse);
        return;
    }
    if (window.web3ChainId == 111456327825 || window.web3ChainId == 111456327830)
    {
        let aptosResponse = await aptosSendContract(contract, method, args, value);
        // if ( azResponse == "received" ) azResponse = {"transactionHash": "0x8e6535d88481117c1f0a32ba8f9bffefe32047dce3e2138eb87f6ab15662b047"};
        console.log("sendContract aptosResponse" + aptosResponse);
        // console.log(typeof concResponse);
        if (typeof aptosResponse != "string" || aptosResponse.length == 0)
        {
            window.web3gl.sendContractResponse = JSON.stringify(aptosResponse);
        }
        else
        {
            window.web3gl.sendContractResponse = aptosResponse;
        }
        console.log("sendContract window.web3gl.sendContractResponse" + window.web3gl.sendContractResponse);
        return;
    }
    if (window.web3ChainId == 11456327825 || window.web3ChainId == 11456327830)
    {
        let azResponse = await alephzeroSendContract(contract, method, args, value);
        if ( azResponse == "received" ) azResponse = {"transactionHash": "0x8e6535d88481117c1f0a32ba8f9bffefe32047dce3e2138eb87f6ab15662b047"};
        console.log("sendContract azResponse" + azResponse);
        // console.log(typeof concResponse);
        if (typeof azResponse != "string" || azResponse.length == 0)
        {
            window.web3gl.sendContractResponse = JSON.stringify(azResponse);
        }
        else
        {
            window.web3gl.sendContractResponse = azResponse;
        }
        console.log(window.web3gl.sendContractResponse);
        return;
    }

    if (window.web3ChainId == 1456327825 || window.web3ChainId == 1456327830)
    {
        let concResponse = await concrodiumSendContract(contract, method, args, value);
        if ( concResponse == "received" ) concResponse = "success";
        console.log(concResponse);
        console.log(typeof concResponse);
        if (typeof concResponse != "string" || concResponse.length == 0)
        {
            window.web3gl.sendContractResponse = JSON.stringify(concResponse);
        }
        else
        {
            window.web3gl.sendContractResponse = concResponse;
        }
        console.log(window.web3gl.sendContractResponse);
        return;
    }
    const account = getAccount()
    const from = account.address
    console.log("sendContract 1 method - " + method);
    console.log("sendContract 1 args - " + JSON.stringify(args));
    // const from = (await web3.eth.getAccounts())[0];
    try{
        if ((parseInt(window.web3ChainId) === 503129905 || parseInt(window.web3ChainId) === 1482601649) && method === 'addMoto') {
            if (window.ethereum) {
                await window.ethereum.request({method: 'eth_requestAccounts'});
                window.web3 = new Web3(window.ethereum);
            }
            const usdc = new window.web3.eth.Contract(JSON.parse(usdcABI), parseInt(window.web3ChainId) === 503129905 ? "0x717d43399ab3a8aada669CDC9560a6BAfdeA9796" : "0xCC205196288B7A26f6D43bBD68AaA98dde97276d");
            const core = new window.web3.eth.Contract(JSON.parse(abi), contract);
            let getMinimalFee = await core.methods.getMinimalFee().call();

            const allowance = await usdc.methods.allowance(from,contract).call();
            if (parseInt(allowance) < parseInt(getMinimalFee)) {
                let approve = await usdc.methods.approve(contract,getMinimalFee).send({
                    from: from
                });
                console.log('USDC approval ' + approve.transactionHash);
            }
            const pastArgs = JSON.parse(args);

            let addMotoToken = await core.methods.addMotoToken(pastArgs[0],parseInt(window.web3ChainId) === 503129905 ? "0x717d43399ab3a8aada669CDC9560a6BAfdeA9796" : "0xCC205196288B7A26f6D43bBD68AaA98dde97276d").send({
                from: from
            });
            console.log('addMotoToken ' + addMotoToken.transactionHash);
            // const tokenIdString = addMotoToken.events.Transfer.tokenId
            window.web3gl.sendContractResponse = JSON.stringify(
                {
                    transactionHash:addMotoToken.transactionHash
                })
            return;
        }
        if ((parseInt(window.web3ChainId) === 503129905 || parseInt(window.web3ChainId) === 1482601649) && method === 'purchase') {

            if (window.ethereum) {
                await window.ethereum.request({method: 'eth_requestAccounts'});
                window.web3 = new Web3(window.ethereum);
            }
            const usdc = new window.web3.eth.Contract(JSON.parse(usdcABI), parseInt(window.web3ChainId) === 503129905 ? "0x717d43399ab3a8aada669CDC9560a6BAfdeA9796" : "0xCC205196288B7A26f6D43bBD68AaA98dde97276d");
            const allowance = await usdc.methods.allowance(from,contract).call();
            if (parseInt(allowance) < parseInt(value)) {
                let approve = await usdc.methods.approve(contract,value).send({
                    from: from
                });
                console.log('USDC approval ' + approve.transactionHash);
            }

            const nft = new window.web3.eth.Contract(JSON.parse(abi), contract);
            const pastArgs = JSON.parse(args);

            let purchaseToken = await nft.methods.purchaseToken(pastArgs[0],pastArgs[1], parseInt(window.web3ChainId) === 503129905 ? "0x717d43399ab3a8aada669CDC9560a6BAfdeA9796" : "0xCC205196288B7A26f6D43bBD68AaA98dde97276d").send({
                from: from
            });
            console.log('purchaseToken ' + purchaseToken.transactionHash);
            const tokenIdString = purchaseToken.events.Transfer.returnValues.tokenId
            window.web3gl.sendContractResponse = JSON.stringify(
                {
                    transactionHash:purchaseToken.transactionHash,
                    events: {
                        Transfer: {
                            returnValues : {
                                tokenId: tokenIdString
                            }
                        }
                    }
                })
            return;
            // value = undefined;
            // method = 'purchaseToken'
            // args = JSON.stringify([pastArgs[0],pastArgs[1], '0x717d43399ab3a8aada669CDC9560a6BAfdeA9796'])
        } else
        if ((parseInt(window.web3ChainId) === 503129905 || parseInt(window.web3ChainId) === 1482601649) && method === 'bidFor') {

            if (window.ethereum) {
                await window.ethereum.request({method: 'eth_requestAccounts'});
                window.web3 = new Web3(window.ethereum);
            }
            const usdc = new window.web3.eth.Contract(JSON.parse(usdcABI), parseInt(window.web3ChainId) === 503129905 ? "0x717d43399ab3a8aada669CDC9560a6BAfdeA9796" : "0xCC205196288B7A26f6D43bBD68AaA98dde97276d");
            const allowance = await usdc.methods.allowance(from,contract).call();
            if (parseInt(allowance) < parseInt(value)) {
                let approve = await usdc.methods.approve(contract,value).send({
                    from: from
                });
                console.log('USDC approval ' + approve.transactionHash);
            }

            const core = new window.web3.eth.Contract(JSON.parse(abi), contract);
            const pastArgs = JSON.parse(args);

            let bidForToken = await core.methods.bidForToken(pastArgs[0],pastArgs[1], parseInt(window.web3ChainId) === 503129905 ? "0x717d43399ab3a8aada669CDC9560a6BAfdeA9796" : "0xCC205196288B7A26f6D43bBD68AaA98dde97276d", value).send({
                from: from
            });
            console.log('bidForToken ' + bidForToken.transactionHash);
            window.web3gl.sendContractResponse = JSON.stringify(
                {
                    transactionHash:bidForToken.transactionHash,
                })
            return;
            // value = undefined;
            // method = 'purchaseToken'
            // args = JSON.stringify([pastArgs[0],pastArgs[1], '0x717d43399ab3a8aada669CDC9560a6BAfdeA9796'])
        } else {


        }
        console.log("sendContract 2 method - " + method);
        console.log("sendContract 2 args - " + JSON.stringify(args));

        const { hash } = await writeContract({
            address: contract,
            abi: JSON.parse(abi),
            functionName: method,
            args: JSON.parse(args),
            value:value
        })
        const data = await waitForTransaction({
            hash: hash,
        })
        console.log("sendContract data - " + data);
        // window.web3gl.sendContractResponse = toJson(data)

        // const transaction = await fetchTransaction({
        //     hash: hash,
        // })
        // console.log("sendContract transaction - " + transaction);
        if (method === "purchase") {
            const tokenIdHex = data.logs[0].topics[3]
            console.log("sendContract tokenIdHex - " + tokenIdHex);
            const tokenIdBigInt = BigInt(tokenIdHex)
            console.log("sendContract tokenIdBigInt - " + tokenIdBigInt);
            const tokenIdString = tokenIdBigInt.toString()
            console.log("sendContract tokenIdString - " + tokenIdString);

            window.web3gl.sendContractResponse = JSON.stringify(
                {
                    transactionHash:hash,
                    events: {
                        Transfer: {
                            returnValues : {
                                tokenId: tokenIdString
                            }
                        }
                    }
                })

        } else {
            window.web3gl.sendContractResponse = JSON.stringify(
                {
                    transactionHash:hash,
                })
        }

        // new web3.eth.Contract(JSON.parse(abi), contract).methods[method](...JSON.parse(args))
        //     .send({
        //         from,
        //         value: value ? value : undefined,
        //         gas: gasLimit ? gasLimit : undefined,
        //         gasPrice: gasPrice ? gasPrice : undefined,
        //     })
        //     .on("transactionHash", (transactionHash) => {
        //         //window.web3gl.sendContractResponse = transactionHash;
        //     })
        //     .on('receipt', (receipt) => {
        //         console.log('create NFT RECEIPT');
        //         console.log(receipt);
        //         window.web3gl.sendContractResponse = JSON.stringify(receipt);
        //     })
        //     .on("error", (error) => {
        //         window.web3gl.sendContractResponse = error.message;
        //     });
    } catch (error) {
        console.log(method + " - " + error.message);
        window.web3gl.sendContractResponse = error.message;
    }
}

async function addNetwork(chainId) {
    var eth;
    chainId = parseInt(chainId, 10);

    if (web3gl.networkId == chainId) return;

    if (typeof ethereum !== 'undefined') {
        eth = new Web3(ethereum);
    } else if (typeof web3 !== 'undefined') {
        eth = new Web3(web3.givenProvider);
    } else {
        eth = new Web3(ethereum);
    }

    if (typeof eth !== 'undefined') {
        // let network = 0;
        // window.web3 = new Web3(window.ethereum);
        // network = await web3.eth.getChainId();
        // // network = await web3.eth.getChainId();
        // let netID = network.toString();   // if (netID === chainId.toString()) {
        //     alert("Network has already been added to Metamask.");
        //     return;
        // } else {
        let params;

        console.log('addNetwork chainId ' + chainId);
        switch (chainId) {
            case 56 :
                params = [{
                    chainId: '0x38',
                    chainName: 'Binance Smart Chain Mainnet',
                    nativeCurrency: {
                        name: 'BNB',
                        symbol: 'BNB',
                        decimals: 18
                    },
                    rpcUrls: ['https://bsc-dataseed.binance.org/'],
                    blockExplorerUrls: ['https://bscscan.com']
                }]
                break;
            case 97 :
                params = [{
                    chainId: '0x61',
                    chainName: 'Binance Smart Chain Testnet',
                    nativeCurrency: {
                        name: 'BNB',
                        symbol: 'BNB',
                        decimals: 18
                    },
                    rpcUrls: ['https://data-seed-prebsc-1-s1.binance.org:8545/'],
                    blockExplorerUrls: ['https://testnet.bscscan.com']
                }]
                break;
            case 137 :
                params = [{
                    chainId: '0x89',
                    chainName: 'Polygon Mainnet',
                    nativeCurrency: {
                        name: 'MATIC',
                        symbol: 'MATIC',
                        decimals: 18
                    },
                    rpcUrls: ['https://polygon.llamarpc.com/'], // 'https://polygon-rpc.com'
                    blockExplorerUrls: ['https://polygonscan.com/']
                }]
                break;
            case 1313161555 :
                params = [{
                    chainId: '0x4E454153',
                    chainName: 'Aurora Testnet',
                    nativeCurrency: {
                        name: 'ETH',
                        symbol: 'ETH',
                        decimals: 18
                    },
                    rpcUrls: ['https://testnet.aurora.dev'],
                    blockExplorerUrls: ['https://testnet.aurorascan.dev']
                }]
                break;
            case 1313161554 :
                params = [{
                    chainId: '0x4E454152',
                    chainName: 'Aurora Mainnet',
                    nativeCurrency: {
                        name: 'ETH',
                        symbol: 'ETH',
                        decimals: 18
                    },
                    rpcUrls: ['https://endpoints.omniatech.io/v1/aurora/mainnet/public'], //'https://mainnet.aurora.dev'
                    blockExplorerUrls: ['https://explorer.aurora.dev/']
                }]
                break;
            case 2221 :
                params = [{
                    chainId: '0x8AD',
                    chainName: 'Kava EVM Testnet',
                    nativeCurrency: {
                        name: 'KAVA',
                        symbol: 'KAVA',
                        decimals: 18
                    },
                    rpcUrls: ['https://evm.evm-alpha.kava.io'],
                    blockExplorerUrls: ['https://explorer.evm-alpha.kava.io']
                }]
                break;
            case 2222 :
                params = [{
                    chainId: '0x8AE',
                    chainName: 'Kava EVM',
                    nativeCurrency: {
                        name: 'KAVA',
                        symbol: 'KAVA',
                        decimals: 18
                    },
                    rpcUrls: ['https://evm.kava.io'],
                    blockExplorerUrls: ['https://explorer.kava.io']
                }]
                break;
            case 1001 :
                params = [{
                    chainId: '0x3E9',
                    chainName: 'Klaytn Baobab',
                    nativeCurrency: {
                        name: 'KLAY',
                        symbol: 'KLAY',
                        decimals: 18
                    },
                    rpcUrls: ['https://api.baobab.klaytn.net:8651'],
                    blockExplorerUrls: ['https://baobab.scope.klaytn.com/']
                }]
                break;
            case 4 :
                params = [{
                    chainId: '0x4',
                    chainName: 'Rinkeby Test Network',
                    nativeCurrency: {
                        name: 'RinkebyETH',
                        symbol: 'RinkebyETH',
                        decimals: 18
                    },
                    rpcUrls: ['https://rinkeby.infura.io/v3/'],
                    blockExplorerUrls: ['https://rinkeby.etherscan.io/']
                }]
                break;
            case 18 :
                params = [{
                    chainId: '0x12',
                    chainName: 'ThunderCore Test Network',
                    nativeCurrency: {
                        name: 'TST',
                        symbol: 'TST',
                        decimals: 18
                    },
                    rpcUrls: ['https://testnet-rpc.thundercore.com'],
                    blockExplorerUrls: ['https://explorer-testnet.thundercore.com']
                }]
                break;
            case 15555 :
                params = [{
                    chainId: '0x3CC3',
                    chainName: 'Trust Tesnet',
                    nativeCurrency: {
                        name: 'EVM',
                        symbol: 'EVM',
                        decimals: 18
                    },
                    rpcUrls: ['https://api.testnet-dev.trust.one'],
                    blockExplorerUrls: ['https://trustscan.one']
                }]
                break;
            case 9000 :
                params = [{
                    chainId: '0x2328',
                    chainName: 'Evmos Testnet',
                    nativeCurrency: {
                        name: 'tEVMOS',
                        symbol: 'tEVMOS',
                        decimals: 18
                    },
                    rpcUrls: ['https://eth.bd.evmos.dev:8545'],
                    blockExplorerUrls: ['https://evm.evmos.dev']
                }]
                break;
            case 1281 :
                params = [{
                    chainId: '0x501',
                    chainName: 'Octopus Testnet',
                    nativeCurrency: {
                        name: 'EBAR',
                        symbol: 'EBAR',
                        decimals: 18
                    },
                    rpcUrls: ['https://gateway.testnet.octopus.network/barnacle-evm/wj1hhcverunusc35jifki19otd4od1n5'],
                    blockExplorerUrls: ['https://explorer.testnet.oct.network/barnacle-evm']
                }]
                break;
            case 1029 :
                params = [{
                    chainId: '0x405',
                    chainName: 'BitTorrent Chain Donau',
                    nativeCurrency: {
                        name: 'BTT',
                        symbol: 'BTT',
                        decimals: 18
                    },
                    rpcUrls: ['https://pre-rpc.bt.io/'],
                    blockExplorerUrls: ['https://testscan.bt.io/']
                }]
                break;
            case 50021 :
                params = [{
                    chainId: '0xC365',
                    chainName: 'GTON Testnet',
                    nativeCurrency: {
                        name: 'GCD',
                        symbol: 'GCD',
                        decimals: 18
                    },
                    rpcUrls: ['https://testnet.gton.network/'],
                    blockExplorerUrls: ['https://explorer.testnet.gton.network/']
                }]
                break;
            case 1456327825 :  // Not real, just for Concordium Testnet
                params = [{
                    chainId: '0x56CDCC91',
                    chainName: 'Concordium Testnet',
                    nativeCurrency: {
                        name: 'CCD',
                        symbol: 'CCD',
                        decimals: 18
                    },
                    rpcUrls: [''],
                    blockExplorerUrls: ['']
                }]
                break;
            case 1456327830 :  // Not real, just for Concordium Mainnet
                params = [{
                    chainId: '0x56CDCC96',
                    chainName: 'Concordium Mainnet',
                    nativeCurrency: {
                        name: 'CCD',
                        symbol: 'CCD',
                        decimals: 18
                    },
                    rpcUrls: [''],
                    blockExplorerUrls: ['']
                }]
                break;
            case 7001 :
                params = [{
                    chainId: '0x1B59',
                    chainName: 'ZetaChain Athens Testnet',
                    nativeCurrency: {
                        name: 'aZETA',
                        symbol: 'aZETA',
                        decimals: 18
                    },
                    rpcUrls: ['https://api.athens2.zetachain.com/evm'],
                    blockExplorerUrls: ['https://explorer.athens.zetachain.com/']
                }]
                break;
            case 7000:
                params = [{
                    chainId: '0x1b58',
                    chainName: 'ZetaChain Mainnet',
                    nativeCurrency: {
                        name: 'ZETA',
                        symbol: 'ZETA',
                        decimals: 18
                    },
                    rpcUrls: ['https://zetachain-evm.blockpi.network/v1/rpc/public'],
                    blockExplorerUrls: ['https://explorer.zetachain.com/']
                }]
                break;
            case 5001 :
                params = [{
                    chainId: '0x1389',
                    chainName: 'Mantle Testnet',
                    nativeCurrency: {
                        name: 'MNT',
                        symbol: 'MNT',
                        decimals: 18
                    },
                    rpcUrls: ['https://rpc.testnet.mantle.xyz'],
                    blockExplorerUrls: ['https://explorer.testnet.mantle.xyz']
                }]
                break;
            case 17777 :
                params = [{
                    chainId: '0x4571',
                    chainName: 'EOS EVM Mainnet',
                    nativeCurrency: {
                        name: 'EOS',
                        symbol: 'EOS',
                        decimals: 18
                    },
                    rpcUrls: ['https://api.evm.eosnetwork.com/'],
                    blockExplorerUrls: ['https://explorer.evm.eosnetwork.com/']
                }]
                break;
            case 5000 :
                params = [{
                    chainId: '0x1388',
                    chainName: 'Mantle Mainnet',
                    nativeCurrency: {
                        name: 'MNT',
                        symbol: 'MNT',
                        decimals: 18
                    },
                    rpcUrls: ['https://rpc.mantle.xyz'],
                    blockExplorerUrls: ['https://explorer.testnet.mantle.xyz/']
                }]
                break;
            case 503129905 :
                params = [{
                    chainId: '0x1dfd2731',
                    chainName: 'Skale Testnet',
                    nativeCurrency: {
                        name: 'sFUEL',
                        symbol: 'sFUEL',
                        decimals: 18
                    },
                    rpcUrls: ['https://staging-v3.skalenodes.com/v1/staging-faint-slimy-achird'],
                    blockExplorerUrls: ['https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com/']
                }]
                break;
            case 1482601649 :
                params = [{
                    chainId: '0x585eb4b1',
                    chainName: 'Skale Mainnet',
                    nativeCurrency: {
                        name: 'sFUEL',
                        symbol: 'sFUEL',
                        decimals: 18
                    },
                    rpcUrls: ['https://mainnet.skalenodes.com/v1/green-giddy-denebola'],
                    blockExplorerUrls: ['https://staging-faint-slimy-achird.explorer.staging-v3.skalenodes.com/']
                }]
                break;
            case 8453 :
                params = [{
                    chainId: '0x2105',
                    chainName: 'Base Mainnet',
                    nativeCurrency: {
                        name: 'ETH',
                        symbol: 'ETH',
                        decimals: 18
                    },
                    rpcUrls: ['https://mainnet.base.org'],
                    blockExplorerUrls: ['https://basescan.org']
                }]
                break;
            default:
                alert('Network not supported to adding!');

        }
        if (chainId == 4)
        {
            window.ethereum
                .request({
                    method: "wallet_switchEthereumChain",
                    params: [{ chainId: `0x${window.web3ChainId.toString(16)}` }], // chainId must be in hexadecimal numbers
                });
            return;
        }
        else if (chainId == 1456327825 || chainId == 1456327830)
        {
            return;
        }
        console.log('addNetwork params' + JSON.stringify(params));
        window.ethereum.request({ method: 'wallet_addEthereumChain', params })
            .then(() => {
                window.ethereum
                    .request({
                        method: "wallet_switchEthereumChain",
                        params: [{ chainId: `0x${window.web3ChainId.toString(16)}` }], // chainId must be in hexadecimal numbers
                    }).then(() => {
                    console.log('Add Success');
                    console.log('Switch Success');
                    window.web3gl.addNetworkResponse = "Success";
                })
                    .catch(() => {
                        window.web3gl.addNetworkResponse = "Error";
                        //window.location.reload();
                    });
            })
            .catch((error) => {
                console.log("Error", error.message);
                alert('Network switching may not work, try switching manually in MetaMask.');
                window.web3gl.addNetworkResponse = "Error";
            });
    } else {
        alert('Unable to locate a compatible web3 browser!');
        window.web3gl.addNetworkResponse = "Error";
    }
}

async function changeChainId(chainIdnew) {
    console.log("changeChainId chainIdnew ", chainIdnew);
    window.web3ChainId = chainIdnew

    if (parseInt(chainIdnew) == 1456327825 ||
        parseInt(chainIdnew) == 1456327830 ||
        parseInt(chainIdnew) == 11456327830 ||
        parseInt(chainIdnew) == 11456327830 ||
        parseInt(chainIdnew) == 111456327830 ||
        parseInt(chainIdnew) == 111456327830 ||
        parseInt(chainIdnew) == 1111456327825 ||
        parseInt(chainIdnew) == 1111456327830||
        parseInt(chainIdnew) == 11111456327825 ||
        parseInt(chainIdnew) == 11111456327830 ||
        parseInt(chainIdnew) == 111111456327825 ||
        parseInt(chainIdnew) == 111111456327830 ||
        parseInt(chainIdnew) == 1111111456327825 ||
        parseInt(chainIdnew) == 1111111456327830
    )
    {
        console.log("changeChainId chainIdnew ", chainIdnew);
        //web3modal.closeModal()
        return
    } 

    if (window.web3modal === undefined) { console.log("too early for request"); return; }
    const account = window.getAccount()
    console.log('changeChainId account->',account)
    const network = window.getNetwork()
    console.log('changeChainId network->',network)
    console.log('changeChainId web3gl.networkId->',web3gl.networkId)
    if (network !== undefined && network.chain !== undefined) console.log('changeChainId network.chain.id->',network.chain.id)
    if (network !== undefined && network.chain !== undefined && parseInt(chainIdnew) !== network.chain.id) {
        const chainToChange = parseInt(chainIdnew)
        console.log('changeChainId chainToChange->',chainToChange)
        //web3modal.openModal()
        //switchNetwork(chainToChange)
    }
    window.chains.forEach(function (chain, i) {
        if (chain.id === parseInt(chainIdnew)) {
            console.log("setDefaultChain", chain.id);
            web3modal.setDefaultChain(window.chains[i])
            console.log("changeChainId setDefaultChain ", window.chains[i]);
            web3gl.networkId = chain.id
            if (network !== undefined && network.chain !== undefined && window.switchNetwork !== undefined) window.switchNetwork({
                chainId: chain.id,
            })
        }
    })
    //switchNetwork(chainIdnew)
    // window.web3ChainId = network.chain.id
    // chainId = network.chain.id
    // chainId = parseInt(chainId, 10);
    //   window.web3ChainId = chainId;
    //   addNetwork(window.web3ChainId);
}

async function getLatestEpoch(abi, nftUniV3ContractAddress) {
    console.log("latestEpochUpdate");
    if (window.web3ChainId == 11111456327825 || window.web3ChainId == 11111456327830)
    {
        //az
        // let concResponse = JSON.stringify(await concordiumLatestEpochUpdate(nftUniV3ContractAddress));
        // console.log(concResponse);
        // window.web3gl.getLatestEpochResponse = concResponse;
        window.web3gl.getLatestEpochResponse = "fail";

        return;
    }
    if (window.web3ChainId == 1111456327825 || window.web3ChainId == 1111456327830)
    {
        //az
        // let concResponse = JSON.stringify(await concordiumLatestEpochUpdate(nftUniV3ContractAddress));
        // console.log(concResponse);
        // window.web3gl.getLatestEpochResponse = concResponse;
        window.web3gl.getLatestEpochResponse = "fail";

        return;
    }

    if (window.web3ChainId == 111456327825 || window.web3ChainId == 111456327830)
    {
        // let concResponse = JSON.stringify(await concordiumLatestEpochUpdate(nftUniV3ContractAddress));
        // console.log(concResponse);
        // window.web3gl.getLatestEpochResponse = concResponse;
        let payload = {
            "function": nftUniV3ContractAddress + "::motodex::get_latest_epoch_update",
            functionArguments: [],
        };
        let r = await window.aptos.view({ payload });
        window.web3gl.getLatestEpochResponse = r[0];

        return;
    }

    if (window.web3ChainId == 11456327825 || window.web3ChainId == 11456327830)
    {
        //az
        // let concResponse = JSON.stringify(await concordiumLatestEpochUpdate(nftUniV3ContractAddress));
        // console.log(concResponse);
        // window.web3gl.getLatestEpochResponse = concResponse;
        window.web3gl.getLatestEpochResponse = "fail";

        return;
    }

    if (window.web3ChainId == 1456327825 || window.web3ChainId == 1456327830)
    {
        let concResponse = JSON.stringify(await concordiumLatestEpochUpdate(nftUniV3ContractAddress));
        console.log(concResponse);
        window.web3gl.getLatestEpochResponse = concResponse;
        return;
    }
    if (parseInt(window.web3ChainId) === 503129905 || parseInt(window.web3ChainId) === 1482601649) {
        if (window.ethereum) {
            await window.ethereum.request({method: 'eth_requestAccounts'});
            window.web3 = new Web3(window.ethereum);
        }
        const from = (await window.web3.eth.getAccounts())[0];
        const nftContract = new window.web3.eth.Contract(JSON.parse(abi), nftUniV3ContractAddress);
        let response = await nftContract.methods.latestEpochUpdate().call();
        console.log(response);
        console.log(typeof response);

        if (typeof response != "string")
        {
            window.web3gl.getLatestEpochResponse = JSON.stringify(response);
        }
        else
        {
            window.web3gl.getLatestEpochResponse = response;
        }
        return;
    }

    try {
        let response = await readContract({
            address: nftUniV3ContractAddress,
            abi: JSON.parse(abi),
            functionName: 'latestEpochUpdate'
        })
        window.web3gl.getLatestEpochResponse = toJson(response)
        // const from = (await web3.eth.getAccounts())[0];
        // const nftContract = new web3.eth.Contract(JSON.parse(abi), nftUniV3ContractAddress);
        // let response = await nftContract.methods.latestEpochUpdate().call();
        // console.log(response);
        // console.log(typeof response);
        //
        // if (typeof response != "string")
        // {
        //     window.web3gl.getLatestEpochResponse = JSON.stringify(response);
        // }
        // else
        // {
        //     window.web3gl.getLatestEpochResponse = response;
        // }
        console.log(window.web3gl.getLatestEpochResponse);
    } catch (error) {
        console.log("getLatestEpoch - " + error.message);
        window.web3gl.getLatestEpochResponse = "fail";
    }
}


async function getAllErc721(abi, nftUniV3ContractAddress) {
    if (window.web3ChainId == 111111456327825 || window.web3ChainId == 111111456327830)
    {
        let icpResponse = JSON.stringify(await icpAllNfts(nftUniV3ContractAddress));
        console.log(icpResponse);
        window.web3gl.getAllErc721Response = icpResponse;
        return;
    }

    if (window.web3ChainId == 11111456327825 || window.web3ChainId == 11111456327830)
    {
        let azResponse = JSON.stringify(await suiAllNfts(nftUniV3ContractAddress));
        console.log(azResponse);
        window.web3gl.getAllErc721Response = azResponse;
        return;
    }


    if (window.web3ChainId == 1111456327825 || window.web3ChainId == 1111456327830)
    {
        let azResponse = JSON.stringify(await varaAllNfts(nftUniV3ContractAddress));
        console.log(azResponse);
        window.web3gl.getAllErc721Response = azResponse;
        return;
    }

    if (window.web3ChainId == 111456327825 || window.web3ChainId == 111456327830)
    {

        let azResponse = JSON.stringify(await aptosAllNfts(nftUniV3ContractAddress));
        console.log(azResponse);
        window.web3gl.getAllErc721Response = azResponse;
        return;
    }

    if (window.web3ChainId == 11456327825 || window.web3ChainId == 11456327830)
    {
        let azResponse = JSON.stringify(await alephzeroAllNfts(nftUniV3ContractAddress));
        console.log(azResponse);
        window.web3gl.getAllErc721Response = azResponse;
        return;
    }

    if (window.web3ChainId == 1456327825 || window.web3ChainId == 1456327830)
    {
        let concResponse = JSON.stringify(await concordiumNftTokensForOwners(nftUniV3ContractAddress));
        console.log(concResponse);
        window.web3gl.getAllErc721Response = concResponse;
        return;
    }
    if (parseInt(window.web3ChainId) === 503129905 || parseInt(window.web3ChainId) === 1482601649) {
        try {
            if (window.ethereum) {
                await window.ethereum.request({method: 'eth_requestAccounts'});
                window.web3 = new Web3(window.ethereum);
            }
            const from = (await window.web3.eth.getAccounts())[0];
            const nftContract = new window.web3.eth.Contract(JSON.parse(abi), nftUniV3ContractAddress);
            let balance = parseInt(await nftContract.methods.balanceOf(from).call());
            let data = [];
            while (balance > 0) {
                balance = balance -1;

                const tokenID = await nftContract.methods.tokenOfOwnerByIndex(from,balance+'').call();
                const tokenURI = await nftContract.methods.tokenURI(tokenID).call();
                data.push({"contract": nftUniV3ContractAddress, "tokenId": tokenID.toString(), "uri": tokenURI, "balance":"1"});
            }
            window.web3gl.getAllErc721Response = JSON.stringify(data);
        } catch (error) {
            console.log("getAllErc721 - " + error.message);
            window.web3gl.getAllErc721Response = "fail";
        }
        return
    }

    try {
        const account = getAccount()
        const from = account.address
        let balance = await readContract({
            address: nftUniV3ContractAddress,
            abi: JSON.parse(abi),
            functionName: 'balanceOf',
            args: [from],
        })


        // const from = (await web3.eth.getAccounts())[0];
        // const nftContract = new web3.eth.Contract(JSON.parse(abi), nftUniV3ContractAddress);
        // let balance = parseInt(await nftContract.methods.balanceOf(from).call());
        let data = [];
        while (balance > 0) {
            balance = balance -1n;
            const tokenID = await readContract({
                address: nftUniV3ContractAddress,
                abi: JSON.parse(abi),
                functionName: 'tokenOfOwnerByIndex',
                args: [from,balance+''],
            })
            const tokenURI = await readContract({
                address: nftUniV3ContractAddress,
                abi: JSON.parse(abi),
                functionName: 'tokenURI',
                args: [tokenID.toString()],
            })
            //   const tokenID = await nftContract.methods.tokenOfOwnerByIndex(from,balance+'').call();
            // const tokenURI = await nftContract.methods.tokenURI(tokenID).call();
            data.push({"contract": nftUniV3ContractAddress, "tokenId": tokenID.toString(), "uri": tokenURI, "balance":"1"});
        }
        window.web3gl.getAllErc721Response = JSON.stringify(data);
    } catch (error) {
        console.log("getAllErc721 - " + error.message);
        window.web3gl.getAllErc721Response = "fail";
    }
}

// ======== APTOS
async function aptosAllNfts(motoDexContract, wallet) {

    let body = JSON.stringify({
        function: motoDexContract + "::motodex::get_collection_address",
        type_arguments: [],
        arguments: []
    });

    let response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
        method: "POST",
        body: body,
        headers: {
            "Content-type": "application/json"
        }
    });
    let response_json = await response_fetch.json();
    let collection_address =response_json[0];

    const collection = await window.aptos.getAccountOwnedTokensFromCollectionAddress(
        {
            accountAddress: window.aptosWalletAddress,
            collectionAddress: collection_address,
        });
    let data = []

    for (let i = 0; i < collection.length; i++) {
        let nft = collection[i];
        let token_id = nft.token_data_id

        body = JSON.stringify({
            function: motoDexContract + "::motodex::get_health_for",
            type_arguments: [],
            arguments: [token_id]
        });
        response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
            method: "POST",
            body: body,
            headers: {
                "Content-type": "application/json"
            }
        });
        response_json = await response_fetch.json();
        let tokenHealth =response_json[0];

        body = JSON.stringify({
            function: motoDexContract + "::motodex::get_type_for",
            type_arguments: [],
            arguments: [token_id]
        });
        response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
            method: "POST",
            body: body,
            headers: {
                "Content-type": "application/json"
            }
        });
        response_json = await response_fetch.json();
        let tokenTypeInt = parseInt(response_json[0]);

        body = JSON.stringify({
            function: motoDexContract + "::motodex::get_price_for_type",
            type_arguments: [],
            arguments: [response_json[0]]
        });
        response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
            method: "POST",
            body: body,
            headers: {
                "Content-type": "application/json"
            }
        });
        response_json = await response_fetch.json();
        let tokenPrice = response_json[0];


        data.push({
            "contract": motoDexContract,
            "tokenId": token_id,
            "uri": nft.current_token_data.token_uri,
            "balance" : "1",
            "currHealthWei" : tokenHealth,
            "maxHealthWei" : tokenPrice,
            "maxHealth" : 200000,
            "ItemData":{
                "name" : "",
                "description" : "",
                "image" : nft.current_token_data.token_uri,
                "type" : tokenTypeInt,
                "price" : 5,
            }
        });
    }

    console.log("aptosAllNfts - collection.length " + collection.length);
    console.log("alephzeroAllNfts - data " + JSON.stringify(data));
    return data;
}

async function aptosSendContract(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;
    try {
        switch (method) {
            case "purchase" :
                response = await window.petraWallet.signAndSubmitTransaction({
                    sender: window.aptosWalletAddress,
                    data: {
                        function: motoDexContract + "::motodex::purchase",
                        typeArguments: [],
                        functionArguments: [args[0]]
                    },
                });
                console.log('aptosSendContract 1 response', response);
                await aptos.waitForTransaction({ transactionHash: response.hash });
                console.log('aptosSendContract 2  response', response);
                let token_id = response.events[2].data.token;
                console.log('aptosSendContract 3  token_id', token_id);

                response = [token_id,response.hash];
                break;
            case "addMoto" :
                response = await window.petraWallet.signAndSubmitTransaction({
                    sender: window.aptosWalletAddress,
                    data: {
                        function: motoDexContract + "::motodex::add_nft",
                        typeArguments: [],
                        functionArguments: [args[0]]
                    },
                });
                console.log('aptosSendContract 1 response', response);
                await aptos.waitForTransaction({ transactionHash: response.hash });
                console.log('aptosSendContract 2  response', response);
                response = response.hash;
                break;
            case "addTrack" :
                response = await window.petraWallet.signAndSubmitTransaction({
                    sender: window.aptosWalletAddress,
                    data: {
                        function: motoDexContract + "::motodex::add_nft",
                        typeArguments: [],
                        functionArguments: [args[0]]
                    },
                });
                console.log('aptosSendContract 1 response', response);
                await aptos.waitForTransaction({ transactionHash: response.hash });
                console.log('aptosSendContract 2  response', response);
                response = response.hash;
                break;
            case "returnMoto" :
                response = await window.petraWallet.signAndSubmitTransaction({
                    sender: window.aptosWalletAddress,
                    data: {
                        function: motoDexContract + "::motodex::return_nft",
                        typeArguments: [],
                        functionArguments: [args[0]]
                    },
                });
                console.log('aptosSendContract 1 response', response);
                await aptos.waitForTransaction({ transactionHash: response.hash });
                console.log('aptosSendContract 2  response', response);
                response = response.hash;
                break;
                // response = await alephzeroReturnMoto(motoDexContract, String(args[0]));
                break;
            case "returnTrack" :
                response = await window.petraWallet.signAndSubmitTransaction({
                    sender: window.aptosWalletAddress,
                    data: {
                        function: motoDexContract + "::motodex::return_nft",
                        typeArguments: [],
                        functionArguments: [args[0]]
                    },
                });
                console.log('aptosSendContract 1 response', response);
                await aptos.waitForTransaction({ transactionHash: response.hash });
                console.log('aptosSendContract 2  response', response);
                response = response.hash;
                // response = await alephzeroReturnTrack(motoDexContract, String(args[0]));
                break;
            case "addHealthNFT" :
                response = await window.petraWallet.signAndSubmitTransaction({
                    sender: window.aptosWalletAddress,
                    data: {
                        function: motoDexContract + "::motodex::add_health_nft",
                        typeArguments: [],
                        functionArguments: [args[0],args[1]]
                    },
                });
                console.log('aptosSendContract 1 response', response);
                await aptos.waitForTransaction({ transactionHash: response.hash });
                console.log('aptosSendContract 2  response', response);
                response = response.hash;
                // response = await alephzeroAddHealthNFT(motoDexContract, String(args[0]),  String(args[1]));
                break;
            case "addHealthMoney" :
                response = await window.petraWallet.signAndSubmitTransaction({
                    sender: window.aptosWalletAddress,
                    data: {
                        function: motoDexContract + "::motodex::add_health_money",
                        typeArguments: [],
                        functionArguments: [args[0]]
                    },
                });
                console.log('aptosSendContract 1 response', response);
                await aptos.waitForTransaction({ transactionHash: response.hash });
                console.log('aptosSendContract 2  response', response);
                response = response.hash;
                // response = await alephzeroAddHealthMoney(motoDexContract, String(args[0]));
                break;
            case "updateCounter" :
                response = await window.petraWallet.signAndSubmitTransaction({
                    sender: window.aptosWalletAddress,
                    data: {
                        function: motoDexContract + "::motodex::update_counter",
                        typeArguments: [],
                        functionArguments: []
                    },
                });
                console.log('aptosSendContract 1 response', response);
                await aptos.waitForTransaction({ transactionHash: response.hash });
                console.log('aptosSendContract 2  response', response);
                response = response.hash;
                break;
            case "bidFor" :
                alert('Method is not added');
                // response = await concordiumBidFor(motoDexContract, String(args[0]),  String(args[1]), value);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }
    return response;
}

async function aptosMethodCall(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;

    try {
        let body;
        let response_fetch;
        let response_json;
        let payload;
        let r;
        switch (method) {
            case "getLimitsAndCounters" :
                response = [];
                break;
            case "balanceOf" :
                let url = "https://fullnode.mainnet.aptoslabs.com/v1/accounts/" + args[0].replaceAll("\"","") + "/resources"
                response_fetch = await fetch(url, {
                    method: "GET",
                    headers: {
                        "Content-type": "application/json"
                    }
                });
                response_json = await response_fetch.json();
                response = "fail";

                for (let i = 0; i < response_json.length; i++) {
                    let value = response_json[i];
                    if (value.type === '0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>') {
                        response = value.data.coin.value;
                    }
                }

                break;
            case "tokenIdsAndOwners" :
                payload = {
                    "function": motoDexContract + "::motodex::get_nft_owners",
                    functionArguments: [],
                };
                r = await window.aptos.view({ payload });

                const data = r[0].data;

                let result = []
                for (let i = 0; i < data.length; i++) {

                    let info = data[i];
                    let nft_address = info.key;
                    let type = info.value.token_type;
                    let type_string

                    if (type < 10) {

                        result.push({"track_token_id":"","track_type":"","moto_token_id":nft_address,"moto_type":type + '',"owner_id":info.value.owner_id,"activeSession":""});
                    } else {
                        result.push({"track_token_id":nft_address,"track_type":type + '',"moto_token_id":"","moto_type":"","owner_id":info.value.owner_id,"activeSession":""});
                    }
                }

                response = result;
                break;
            case "getPriceForType" :

                if (args[0] === '7') {
                    response ="0";
                } else {

                    payload = {
                        "function": motoDexContract + "::motodex::get_price_for_type",
                        functionArguments: [parseInt(args[0])],
                    };
                    r = await window.aptos.view({ payload });

                    response = r[0];
                }


                break;
            case "valueInMainCoin" :
                if (parseInt(args[0]) > 150) {
                    response = "0"
                } else {
                    payload = {
                        "function": motoDexContract + "::motodex::get_price_for_type",
                        functionArguments: [parseInt(args[0])],
                    };
                    r = await window.aptos.view({ payload });

                    response = r[0];
                }

                break;
            case "getTokenType" :

                payload = {
                    "function": motoDexContract + "::motodex::get_type_for",
                    functionArguments: [args[0]],
                };
                r = await window.aptos.view({ payload });

                response = r[0];
                break;
            case "getHealthForId" :
                payload = {
                    "function": motoDexContract + "::motodex::get_health_for",
                    functionArguments: [args[0]],
                };
                r = await window.aptos.view({ payload });

                response = r[0];
                break;
            case "getPercentForTrack" :
                response = '30';//await concordiumGetPercentForTrack(motoDexContract, args[0]);
                break;
            case "getGameSessions" :

                response = [];//// response = await concordiumGetGameSessions(motoDexContract);
                break;
            case "getAllGameBids" :
                response = [];//await concordiumGetAllGameBids(motoDexContract);
                break;
            case "latestEpochUpdate" :
                payload = {
                    "function": motoDexContract + "::motodex::get_latest_epoch_update",
                    functionArguments: [args[0]],
                };
                r = await window.aptos.view({ payload });
                response = r[0];
                break;
            case "minimalFeeInUSD" :
                payload = {
                    "function": motoDexContract + "::motodex::get_minimal_fee",
                    functionArguments: [],
                };
                r = await window.aptos.view({ payload });
                response = r[0];
                break;
            case "getLatestPrice" :
                payload = {
                    "function": motoDexContract + "::motodex::get_price_main_coin_usd",
                    functionArguments: [],
                };
                r = await window.aptos.view({ payload });
                response = r[0];
                break;
            case "syncEpochResultsBidsFinal" :
                // response = await concordiumSyncEpochResultsBidsFinal(motoDexContract);
                break;
            case "syncEpochResultsMotosFinal" :
                // response = await concordiumSyncEpochResultsMotosFinal(motoDexContract);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }

    return response;
}

// ======== SUI

const PACKAGE_ID="0x7f8ad597e589e66606c4f5f484cb5a3e808701483dd43afe61cec10b97961745"
const MOTODEX_ID="0x615eefc28a5183bec1310632407d2b9c2fc2395a1a2cbeda362aa7877992aab3"

const PACKAGE_ID_TESTNET="0x2aa0d659d7c324abf446863ef9dc93d622cff82b642d09f8cc3a3f81169f16a9"
const MOTODEX_ID_TESTNET="0xc28d578a60bd68cce73e5e14a47fc4716378ceaa0d14e5b44270d9dfff3ec9dd"
async function coinIdSUI() {

    let body = JSON.stringify({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "suix_getCoins",
        "params": [
            window.suiWalletAddress,
            "0x2::sui::SUI"
        ]
    });


    let url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"
    let response_fetch = await fetch(url, {
        method: "POST",
        body: body,
        headers: {
            "Content-type": "application/json"
        }
    });
    let response_json = await response_fetch.json();
    let all_coins = response_json.result.data;
    let max_balance = 0;
    let coin_id;
    for (let i = 0; i < all_coins.length; i++) {
        let coin = all_coins[i];
        if (parseInt(coin.balance) > max_balance && coin.coinType === "0x2::sui::SUI") {
            max_balance = parseInt(coin.balance);
            coin_id = coin.coinObjectId
        }
    }
    return coin_id
}

async function motodexObjectSUI() {

    let body = JSON.stringify({
        "jsonrpc": "2.0",
        "id": 1,
        "method": "sui_getObject",
        "params": [
            MOTODEX_ID,
            {
                "showType": true,
                "showOwner": true,
                "showPreviousTransaction": true,
                "showDisplay": false,
                "showContent": true,
                "showBcs": false,
                "showStorageRebate": true
            }
        ]
    });


    let url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"
    let response_fetch = await fetch(url, {
        method: "POST",
        body: body,
        headers: {
            "Content-type": "application/json"
        }
    });
    let response_json = await response_fetch.json();
    return response_json
}

async function inputFromArguments(args, function_name, value) {
    function bigToUint8Array(big) {
        const big0 = BigInt(0)
        const big1 = BigInt(1)
        const big8 = BigInt(8)

        if (big < big0) {
            const bits = (new BigInt(big.toString(2).length) / big8 + big1) * big8
            const prefix1 = big1 << bits
            big += prefix1
        }
        let hex = big.toString(16)
        if (hex.length % 2) {
            hex = '0' + hex
        }
        const len = 8//hex.length / 2
        const u8 = new Uint8Array(len)
        var i = 3
        var j = 0
        while (i !== -1) {
            u8[i] = parseInt(hex.slice(j, j + 2), 16)
            i -= 1
            j += 2
        }
        return u8
    }

    // let pure = Array.from(bigToUint8Array(value))


    let inputs = []
    if (value !== undefined) {
        inputs.push({
            "kind":"Input",
            "value":{
                "Pure":Array.from(bigToUint8Array(value))
            },
            "index":0,
            "type":"pure"
        })
    }
    let arguments_for_tx = []

    for (let i = 0; i < args.length; i++) {
        const argument = args[i];
        let index = (value !== undefined) ? i + 1 : i;
        inputs.push({"kind":"Input","value":argument,"index":index,"type":"pure"})
        arguments_for_tx.push({"kind":"Input","value":argument,"index":index,"type":"pure"})
    }
    if (value !== undefined) {
        arguments_for_tx.push({"kind": "NestedResult", "index": 0, "resultIndex": 0})
    }
    let transactions = []
    if (value !== undefined) {
        transactions.push({
            "kind":"SplitCoins",
            "coin":
                {
                    "kind":"GasCoin"
                },
            "amounts":[
                {
                    "kind":"Input",
                    "value":
                        {
                            "Pure":Array.from(bigToUint8Array(value))
                        },
                    "index":0,
                    "type":"pure"
                }]
        })
    }
    transactions.push(
        {
            "kind":"MoveCall",
            "target":PACKAGE_ID + "::core::" + function_name, // package_ID::code::function
            "arguments":arguments_for_tx,
            "typeArguments":[]
        }
    )

    const tx = {
        "version":1,
        "gasConfig":{},
        "inputs":inputs,
        "transactions": transactions
    }
    const input = {
        transactionBlockSerialized: JSON.stringify(tx),
        options: {
            showEffects: true,
            showEvents: true,
            showObjectChanges: true
        }
    }
    return input
}

async function suiAllNfts(motoDexContract, wallet) {

    let body = JSON.stringify({
        function: motoDexContract + "::motodex::get_collection_address",
        type_arguments: [],
        arguments: []
    });

    let response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
        method: "POST",
        body: body,
        headers: {
            "Content-type": "application/json"
        }
    });
    let response_json = await response_fetch.json();
    let collection_address =response_json[0];

    const collection = await window.aptos.getAccountOwnedTokensFromCollectionAddress(
        {
            accountAddress: window.aptosWalletAddress,
            collectionAddress: collection_address,
        });
    let data = []

    for (let i = 0; i < collection.length; i++) {
        let nft = collection[i];
        let token_id = nft.token_data_id

        body = JSON.stringify({
            function: motoDexContract + "::motodex::get_health_for",
            type_arguments: [],
            arguments: [token_id]
        });
        response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
            method: "POST",
            body: body,
            headers: {
                "Content-type": "application/json"
            }
        });
        response_json = await response_fetch.json();
        let tokenHealth =response_json[0];

        body = JSON.stringify({
            function: motoDexContract + "::motodex::get_type_for",
            type_arguments: [],
            arguments: [token_id]
        });
        response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
            method: "POST",
            body: body,
            headers: {
                "Content-type": "application/json"
            }
        });
        response_json = await response_fetch.json();
        let tokenTypeInt = parseInt(response_json[0]);

        body = JSON.stringify({
            function: motoDexContract + "::motodex::get_price_for_type",
            type_arguments: [],
            arguments: [response_json[0]]
        });
        response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
            method: "POST",
            body: body,
            headers: {
                "Content-type": "application/json"
            }
        });
        response_json = await response_fetch.json();
        let tokenPrice = response_json[0];


        data.push({
            "contract": motoDexContract,
            "tokenId": token_id,
            "uri": nft.current_token_data.token_uri,
            "balance" : "1",
            "currHealthWei" : tokenHealth,
            "maxHealthWei" : tokenPrice,
            "maxHealth" : 200000,
            "ItemData":{
                "name" : "",
                "description" : "",
                "image" : nft.current_token_data.token_uri,
                "type" : tokenTypeInt,
                "price" : 5,
            }
        });
    }

    console.log("aptosAllNfts - collection.length " + collection.length);
    console.log("alephzeroAllNfts - data " + JSON.stringify(data));
    return data;
}

async function suiSendContract(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;

    let body
    let url
    let response_fetch
    let response_json
    let all_coins
    let max_balance
    let coin_id
    let inputs
    let suiWalletTxHash
    try {
        switch (method) {
            case "purchase" :
                // let coin_id = await coinIdSUI();

                // body = JSON.stringify({
                //     "jsonrpc": "2.0",
                //     "id": 1,
                //     "method": "suix_getCoins",
                //     "params": [
                //         window.suiWalletAddress,
                //         "0x2::sui::SUI"
                //     ]
                // });
                //
                //
                // url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"
                // response_fetch = await fetch(url, {
                //     method: "POST",
                //     body: body,
                //     headers: {
                //         "Content-type": "application/json"
                //     }
                // });
                // response_json = await response_fetch.json();
                // all_coins = response_json.result.data;
                // max_balance = 0;
                // for (let i = 0; i < all_coins.length; i++) {
                //     let coin = all_coins[i];
                //     if (parseInt(coin.balance) > max_balance && coin.coinType === "0x2::sui::SUI") {
                //         max_balance = parseInt(coin.balance);
                //         coin_id = coin.coinObjectId
                //     }
                // }


                // body = JSON.stringify({
                //     "jsonrpc": "2.0",
                //     "id": 1,
                //     "method": "sui_getObject",
                //     "params": [
                //         MOTODEX_ID,
                //         {
                //             "showType": true,
                //             "showOwner": true,
                //             "showPreviousTransaction": true,
                //             "showDisplay": false,
                //             "showContent": true,
                //             "showBcs": false,
                //             "showStorageRebate": true
                //         }
                //     ]
                // });
                //
                //
                // url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"
                // response_fetch = await fetch(url, {
                //     method: "POST",
                //     body: body,
                //     headers: {
                //         "Content-type": "application/json"
                //     }
                // });
                response_json = await motodexObjectSUI();

                let price_usd_array = response_json.result.data.content.fields.nfts.fields.price_usd.fields.contents;
                let one_main_coin = response_json.result.data.content.fields.one_main_coin;
                let price_main_coin_usd = response_json.result.data.content.fields.price_main_coin_usd;
                let priceForTypeMoto = price_usd_array.filter(obj => {
                    return obj.fields.key === parseInt(args[0])
                })[0].fields.value
                let priceForTypeMotoMainCoin = parseInt((priceForTypeMoto * one_main_coin / price_main_coin_usd) + "")

                // Create a transaction
                await window.martian.sui.connect(['viewAccount', 'suggestTransactions']);

                inputs = await inputFromArguments([MOTODEX_ID,args[0], "0x6"], "purchase", BigInt(priceForTypeMotoMainCoin + ''));
                suiWalletTxHash = await window.martian.sui.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock(inputs)
                console.log(suiWalletTxHash);
                console.log(suiWalletTxHash.digest);
                let token_id = suiWalletTxHash.effects.created[0].reference.objectId
                response = [token_id,suiWalletTxHash.digest];
                break;
            case "addMoto" :
                response_json = await motodexObjectSUI();

                // Create a transaction
                await window.martian.sui.connect(['viewAccount', 'suggestTransactions']);

                inputs = await inputFromArguments([MOTODEX_ID,args[0], "0x6"], "add_nft", BigInt(response_json.result.data.content.fields.minimal_fee + ''));
                suiWalletTxHash = await window.martian.sui.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock(inputs)
                console.log(suiWalletTxHash);
                console.log(suiWalletTxHash.digest);
                response = suiWalletTxHash.digest;

                break;
            case "addTrack" :
                response_json = await motodexObjectSUI();

                // Create a transaction
                await window.martian.sui.connect(['viewAccount', 'suggestTransactions']);

                inputs = await inputFromArguments([MOTODEX_ID,args[0], "0x6"], "add_nft", BigInt(response_json.result.data.content.fields.minimal_fee + ''));
                suiWalletTxHash = await window.martian.sui.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock(inputs)
                console.log(suiWalletTxHash);
                console.log(suiWalletTxHash.digest);
                response = suiWalletTxHash.digest;
                break;
            case "returnMoto" :

                // Create a transaction
                await window.martian.sui.connect(['viewAccount', 'suggestTransactions']);

                inputs = await inputFromArguments([MOTODEX_ID,args[0], "0x6"], "return_nft");
                suiWalletTxHash = await window.martian.sui.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock(
                    inputs
                    // {"transactionBlockSerialized":"{\"version\":1,\"gasConfig\":{},\"inputs\":[{\"kind\":\"Input\",\"value\":\"0x420cd3a0c8f8df6763eb6b211cd08d8ce8e0b40428c6a7e17c3dd614cd8eb834\",\"index\":0,\"type\":\"pure\"},{\"kind\":\"Input\",\"value\":\"0xe13dd943880d88a3ea4517cae1b45f623d72ede5db440082940dd5a853aa4bea\",\"index\":1,\"type\":\"pure\"},{\"kind\":\"Input\",\"value\":\"0x6\",\"index\":2,\"type\":\"pure\"}],\"transactions\":[{\"kind\":\"MoveCall\",\"target\":\"0x4648f161a1e6403505525d908e48cc6750338a0a1f6aff86ca0c0e865c47c64a::core::return_nft\",\"arguments\":[{\"kind\":\"Input\",\"value\":\"0x420cd3a0c8f8df6763eb6b211cd08d8ce8e0b40428c6a7e17c3dd614cd8eb834\",\"index\":0,\"type\":\"pure\"},{\"kind\":\"Input\",\"value\":\"0xe13dd943880d88a3ea4517cae1b45f623d72ede5db440082940dd5a853aa4bea\",\"index\":1,\"type\":\"pure\"},{\"kind\":\"Input\",\"value\":\"0x6\",\"index\":2,\"type\":\"pure\"}],\"typeArguments\":[]}]}","options":{"showEffects":true}}
                )
                console.log(suiWalletTxHash);
                console.log(suiWalletTxHash.digest);
                response = suiWalletTxHash.digest;
                break;
            case "returnTrack" :
                // Create a transaction
                await window.martian.sui.connect(['viewAccount', 'suggestTransactions']);

                inputs = await inputFromArguments([MOTODEX_ID,args[0], "0x6"], "return_nft");
                suiWalletTxHash = await window.martian.sui.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock(inputs)
                console.log(suiWalletTxHash);
                console.log(suiWalletTxHash.digest);
                response = suiWalletTxHash.digest;
                break;
            case "addHealthNFT" :
                response = await window.petraWallet.signAndSubmitTransaction({
                    sender: window.aptosWalletAddress,
                    data: {
                        function: motoDexContract + "::motodex::add_health_nft",
                        typeArguments: [],
                        functionArguments: [args[0],args[1]]
                    },
                });
                console.log('aptosSendContract 1 response', response);
                await aptos.waitForTransaction({ transactionHash: response.hash });
                console.log('aptosSendContract 2  response', response);
                response = response.hash;
                // response = await alephzeroAddHealthNFT(motoDexContract, String(args[0]),  String(args[1]));
                break;
            case "addHealthMoney" :
                response = await window.petraWallet.signAndSubmitTransaction({
                    sender: window.aptosWalletAddress,
                    data: {
                        function: motoDexContract + "::motodex::add_health_money",
                        typeArguments: [],
                        functionArguments: [args[0]]
                    },
                });
                console.log('aptosSendContract 1 response', response);
                await aptos.waitForTransaction({ transactionHash: response.hash });
                console.log('aptosSendContract 2  response', response);
                response = response.hash;
                // response = await alephzeroAddHealthMoney(motoDexContract, String(args[0]));
                break;
            case "updateCounter" :
                await window.martian.sui.connect(['viewAccount', 'suggestTransactions']);
                inputs = await inputFromArguments([MOTODEX_ID, "0x6"], "update_counter");
                suiWalletTxHash = await window.martian.sui.features["sui:signAndExecuteTransactionBlock"].signAndExecuteTransactionBlock(inputs)
                console.log(suiWalletTxHash);
                console.log(suiWalletTxHash.digest);
                response = suiWalletTxHash.digest

                break;
            case "bidFor" :
                alert('Method is not added');
                // response = await concordiumBidFor(motoDexContract, String(args[0]),  String(args[1]), value);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }
    return response;
}

async function suiMethodCall(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;


    try {
        let url;
        let body;
        let response_fetch;
        let response_json;
        let payload;
        let r;
        let price_usd_array;
        let priceForTypeMoto;

        switch (method) {
            case "getLimitsAndCounters" :
                response = [];
                break;
            case "balanceOf" :
                body = JSON.stringify({
                    "jsonrpc": "2.0",
                    "id": 1,
                    "method": "suix_getBalance",
                    "params": [
                        window.suiWalletAddress,
                        "0x2::sui::SUI"
                    ]
                });


                url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"
                response_fetch = await fetch(url, {
                    method: "POST",
                    body: body,
                    headers: {
                        "Content-type": "application/json"
                    }
                });
                response_json = await response_fetch.json();
                response = response_json.result.totalBalance;

                break;
            case "tokenIdsAndOwners" :
                body = JSON.stringify({
                    "jsonrpc": "2.0",
                    "id": 1,
                    "method": "sui_getObject",
                    "params": [
                        MOTODEX_ID,
                        {
                            "showType": true,
                            "showOwner": true,
                            "showPreviousTransaction": true,
                            "showDisplay": false,
                            "showContent": true,
                            "showBcs": false,
                            "showStorageRebate": true
                        }
                    ]
                });


                url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"
                response_fetch = await fetch(url, {
                    method: "POST",
                    body: body,
                    headers: {
                        "Content-type": "application/json"
                    }
                });
                response_json = await response_fetch.json();

                const data = response_json.result.data.content.fields.nft_owners.fields.contents;

                let result = []
                for (let i = 0; i < data.length; i++) {

                    let info = data[i];
                    let fields = info.fields;
                    let type = fields.value.fields.token_type;
                    let nft_address = fields.key
                    let owner_id = fields.value.fields.owner_id

                    if (type < 10) {
                        result.push({"track_token_id":"","track_type":"","moto_token_id":nft_address,"moto_type":type + '',"owner_id":owner_id,"activeSession":""});
                    } else {
                        result.push({"track_token_id":nft_address,"track_type":type + '',"moto_token_id":"","moto_type":"","owner_id":owner_id,"activeSession":""});
                    }
                }

                response = result;
                break;
            case "getPriceForType" :

                body = JSON.stringify({
                    "jsonrpc": "2.0",
                    "id": 1,
                    "method": "sui_getObject",
                    "params": [
                        MOTODEX_ID,
                        {
                            "showType": true,
                            "showOwner": true,
                            "showPreviousTransaction": true,
                            "showDisplay": false,
                            "showContent": true,
                            "showBcs": false,
                            "showStorageRebate": true
                        }
                    ]
                });


                url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"
                response_fetch = await fetch(url, {
                    method: "POST",
                    body: body,
                    headers: {
                        "Content-type": "application/json"
                    }
                });
                response_json = await response_fetch.json();

                price_usd_array = response_json.result.data.content.fields.nfts.fields.price_usd.fields.contents;

                priceForTypeMoto = price_usd_array.filter(obj => {
                    return obj.fields.key === parseInt(args[0])
                })[0].fields.value
                response = priceForTypeMoto + ''


                break;
            case "valueInMainCoin" :
                body = JSON.stringify({
                    "jsonrpc": "2.0",
                    "id": 1,
                    "method": "sui_getObject",
                    "params": [
                        MOTODEX_ID,
                        {
                            "showType": true,
                            "showOwner": true,
                            "showPreviousTransaction": true,
                            "showDisplay": false,
                            "showContent": true,
                            "showBcs": false,
                            "showStorageRebate": true
                        }
                    ]
                });


                url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"
                response_fetch = await fetch(url, {
                    method: "POST",
                    body: body,
                    headers: {
                        "Content-type": "application/json"
                    }
                });
                response_json = await response_fetch.json();

                price_usd_array = response_json.result.data.content.fields.nfts.fields.price_usd.fields.contents;
                let one_main_coin = response_json.result.data.content.fields.one_main_coin;
                let price_main_coin_usd = response_json.result.data.content.fields.price_main_coin_usd;
                priceForTypeMoto = price_usd_array.filter(obj => {
                    return obj.fields.key === parseInt(args[0])
                })[0].fields.value
                let priceForTypeMotoMainCoin = priceForTypeMoto * one_main_coin / price_main_coin_usd
                response = parseInt(priceForTypeMotoMainCoin + '') + ''

                break;
            case "getTokenType" :

                payload = {
                    "function": motoDexContract + "::motodex::get_type_for",
                    functionArguments: [args[0]],
                };
                r = await window.aptos.view({ payload });

                response = r[0];
                break;
            case "getHealthForId" :
                body = JSON.stringify({
                    "jsonrpc": "2.0",
                    "id": 1,
                    "method": "sui_getObject",
                    "params": [
                        MOTODEX_ID,
                        {
                            "showType": true,
                            "showOwner": true,
                            "showPreviousTransaction": true,
                            "showDisplay": false,
                            "showContent": true,
                            "showBcs": false,
                            "showStorageRebate": true
                        }
                    ]
                });


                url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"
                response_fetch = await fetch(url, {
                    method: "POST",
                    body: body,
                    headers: {
                        "Content-type": "application/json"
                    }
                });
                response_json = await response_fetch.json();
                let token_health = response_json.result.data.content.fields.token_health.fields.contents;

                let healthFinal = 0
                for (let i = 0; i < token_health.length; i++) {

                    let info = token_health[i];
                    let objectId = info.fields.key
                    let health = info.fields.value
                    if (objectId.toLowerCase() === args[0].toLowerCase()) {
                        healthFinal = health
                        break
                    }
                }
                response = healthFinal;
                break;
            case "getPercentForTrack" :
                response = '30';//await concordiumGetPercentForTrack(motoDexContract, args[0]);
                break;
            case "getGameSessions" :

                response = [];//// response = await concordiumGetGameSessions(motoDexContract);
                break;
            case "getAllGameBids" :
                response = [];//await concordiumGetAllGameBids(motoDexContract);
                break;
            case "latestEpochUpdate" :
                payload = {
                    "function": motoDexContract + "::motodex::get_latest_epoch_update",
                    functionArguments: [args[0]],
                };
                r = await window.aptos.view({ payload });
                response = r[0];
                break;
            case "minimalFeeInUSD" :
                body = JSON.stringify({
                    "jsonrpc": "2.0",
                    "id": 1,
                    "method": "sui_getObject",
                    "params": [
                        MOTODEX_ID,
                        {
                            "showType": true,
                            "showOwner": true,
                            "showPreviousTransaction": true,
                            "showDisplay": false,
                            "showContent": true,
                            "showBcs": false,
                            "showStorageRebate": true
                        }
                    ]
                });


                url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"
                response_fetch = await fetch(url, {
                    method: "POST",
                    body: body,
                    headers: {
                        "Content-type": "application/json"
                    }
                });
                response_json = await response_fetch.json();

                const minimal_fee = response_json.result.data.content.fields.minimal_fee;
                response = minimal_fee + ''

                break;
            case "getLatestPrice" :
                payload = {
                    "function": motoDexContract + "::motodex::get_price_main_coin_usd",
                    functionArguments: [],
                };
                r = await window.aptos.view({ payload });
                response = r[0];
                break;
            case "syncEpochResultsBidsFinal" :
                // response = await concordiumSyncEpochResultsBidsFinal(motoDexContract);
                break;
            case "syncEpochResultsMotosFinal" :
                // response = await concordiumSyncEpochResultsMotosFinal(motoDexContract);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }

    return response;
}


// ======== ICP


async function icpAllNfts(motoDexContract, wallet) {

    let body = JSON.stringify({
        function: motoDexContract + "::motodex::get_collection_address",
        type_arguments: [],
        arguments: []
    });

    let response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
        method: "POST",
        body: body,
        headers: {
            "Content-type": "application/json"
        }
    });
    let response_json = await response_fetch.json();
    let collection_address =response_json[0];

    const collection = await window.aptos.getAccountOwnedTokensFromCollectionAddress(
        {
            accountAddress: window.aptosWalletAddress,
            collectionAddress: collection_address,
        });
    let data = []

    for (let i = 0; i < collection.length; i++) {
        let nft = collection[i];
        let token_id = nft.token_data_id

        body = JSON.stringify({
            function: motoDexContract + "::motodex::get_health_for",
            type_arguments: [],
            arguments: [token_id]
        });
        response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
            method: "POST",
            body: body,
            headers: {
                "Content-type": "application/json"
            }
        });
        response_json = await response_fetch.json();
        let tokenHealth =response_json[0];

        body = JSON.stringify({
            function: motoDexContract + "::motodex::get_type_for",
            type_arguments: [],
            arguments: [token_id]
        });
        response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
            method: "POST",
            body: body,
            headers: {
                "Content-type": "application/json"
            }
        });
        response_json = await response_fetch.json();
        let tokenTypeInt = parseInt(response_json[0]);

        body = JSON.stringify({
            function: motoDexContract + "::motodex::get_price_for_type",
            type_arguments: [],
            arguments: [response_json[0]]
        });
        response_fetch = await fetch("https://fullnode.mainnet.aptoslabs.com/v1/view", {
            method: "POST",
            body: body,
            headers: {
                "Content-type": "application/json"
            }
        });
        response_json = await response_fetch.json();
        let tokenPrice = response_json[0];


        data.push({
            "contract": motoDexContract,
            "tokenId": token_id,
            "uri": nft.current_token_data.token_uri,
            "balance" : "1",
            "currHealthWei" : tokenHealth,
            "maxHealthWei" : tokenPrice,
            "maxHealth" : 200000,
            "ItemData":{
                "name" : "",
                "description" : "",
                "image" : nft.current_token_data.token_uri,
                "type" : tokenTypeInt,
                "price" : 5,
            }
        });
    }

    console.log("aptosAllNfts - collection.length " + collection.length);
    console.log("alephzeroAllNfts - data " + JSON.stringify(data));
    return data;
}

async function icpSendContract(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;

    let body
    let url
    let response_fetch
    let response_json
    let all_coins
    let max_balance
    let coin_id
    let inputs
    let suiWalletTxHash
    const host = (window.web3ChainId != 111111456327830)  ? 'http://127.0.0.1:4943' : 'https://icp-api.io';

    const agent = new window.HttpAgent({
        identity: window.identityICP,
        host ,
    });
    if (window.web3ChainId != 111111456327830) await agent.fetchRootKey()

    const agentMotodex = window.Actor.createActor(window.idlFactoryMotodex, {
        agent,
        canisterId: (window.web3ChainId != 111111456327830) ? "be2us-64aaa-aaaaa-qaabq-cai" : "6sjzu-nyaaa-aaaak-qihqa-cai"
    });

    const agentICP = window.Actor.createActor(window.idlFactoryICP, {
        agent,
        canisterId: "ryjl3-tyaaa-aaaaa-aaaba-cai"
    });
    function stringFrom(object) {
        return JSON.stringify(object, (key, value) =>
            typeof value === 'bigint'
                ? value.toString()
                : value // return everything else unchanged
        );
    }
    const motoDEXprincipalText = (window.web3ChainId != 111111456327830) ? "be2us-64aaa-aaaaa-qaabq-cai" : "6sjzu-nyaaa-aaaak-qihqa-cai";

    const motoDEXprincipal = window.Principal.fromText(motoDEXprincipalText)
    let valueFinal
    let approveArgs
    let icrc2_approve

    try {
        switch (method) {
            case "purchase" :

                valueFinal = await agentMotodex.value_in_main_coin(parseInt(args[0])) + 10000n

                // send all funds back
                // const icrc1_balance_of = await agentICP.icrc1_balance_of({owner:window.identityICP.getPrincipal(), subaccount:[]});
                // console.log("1 icrc1_balance_of " + JSON.stringify(stringFrom(icrc1_balance_of)))
                // let icrc1_transfer_args = {
                //   to : {owner:window.Principal.fromText('reied-uzphq-ioqxu-igzrp-f667e-tlwl3-lxst7-wltyu-jaff3-5jpfo-lae'), subaccount:[]},
                //   fee : [],
                //   memo : [],
                //   from_subaccount : [],
                //   created_at_time : [],
                //   amount : icrc1_balance_of - 10000n,
                // }
                //
                // const result_transfer = await agentICP.icrc1_transfer(icrc1_transfer_args);
                // console.log(" result_transfer " + JSON.stringify(stringFrom(result_transfer)))
                // return;

                // Call the icrc2_approve() function
                approveArgs = {
                    fee: [],
                    memo: [],
                    from_subaccount: [],
                    created_at_time: [],
                    amount: valueFinal,
                    expected_allowance: [],
                    expires_at: [],
                    spender: {
                        owner: motoDEXprincipal, //i also tried the canisterId of the canister i launched
                        subaccount: [],
                    },
                };

                icrc2_approve = await agentICP.icrc2_approve(approveArgs);
                console.log(" icrc2_approve " + JSON.stringify(stringFrom(icrc2_approve)))
                if (icrc2_approve.Ok) {
                    console.log('Approve successful, transaction ID:', icrc2_approve.Ok);
                    const purchase = await agentMotodex.purchase(parseInt(args[0]));
                    if (purchase.Ok) {
                        console.log('purchase successful, token ID:', purchase.Ok);
                        response = [purchase.Ok + '',"done"];
                    } else {
                        console.error('purchase failed:', purchase.Err);
                        response = "fail";
                    }

                } else {
                    console.error('Approve failed:', icrc2_approve.Err);
                    response = "fail";

                }

                break;
            case "addMoto" :
                value = await agentMotodex.get_minimal_fee()+ 10000n

                // Call the icrc2_approve() function
                approveArgs = {
                    fee: [],
                    memo: [],
                    from_subaccount: [],
                    created_at_time: [],
                    amount: value,
                    expected_allowance: [],
                    expires_at: [],
                    spender: {
                        owner: motoDEXprincipal, //i also tried the canisterId of the canister i launched
                        subaccount: [],
                    },
                };

                icrc2_approve = await agentICP.icrc2_approve(approveArgs);
                console.log(" icrc2_approve " + JSON.stringify(stringFrom(icrc2_approve)))
                if (icrc2_approve.Ok) {
                    console.log('Approve successful, transaction ID:', icrc2_approve.Ok);

                    const add_moto = await agentMotodex.add_moto(parseInt(args[0]));
                    if (add_moto.Ok) {
                        console.log('add_moto successful, ID:', add_moto.Ok);
                        response = add_moto.Ok + '';
                    } else {
                        console.error('add_moto failed:', add_moto.Err);
                        response = "fail";
                    }

                } else {
                    console.error('Approve failed:', icrc2_approve.Err);
                    response = "fail";

                }


                break;
            case "addTrack" :


                value = await agentMotodex.get_minimal_fee()+ 10000n

                // Call the icrc2_approve() function
                approveArgs = {
                    fee: [],
                    memo: [],
                    from_subaccount: [],
                    created_at_time: [],
                    amount: value,
                    expected_allowance: [],
                    expires_at: [],
                    spender: {
                        owner: motoDEXprincipal, //i also tried the canisterId of the canister i launched
                        subaccount: [],
                    },
                };

                icrc2_approve = await agentICP.icrc2_approve(approveArgs);
                console.log(" icrc2_approve " + JSON.stringify(stringFrom(icrc2_approve)))
                if (icrc2_approve.Ok) {
                    console.log('Approve successful, transaction ID:', icrc2_approve.Ok);

                    const add_track = await agentMotodex.add_track(parseInt(args[0]));
                    if (add_track.Ok) {
                        console.log('add_track successful, ID:', add_track.Ok);
                        response = add_track.Ok + "";
                    } else {
                        console.error('add_track failed:', add_track.Err);
                        response = "fail";
                    }

                } else {
                    console.error('Approve failed:', icrc2_approve.Err);
                    response = "fail";

                }

                break;
            case "returnMoto" :

                const return_moto = await agentMotodex.return_moto(parseInt(args[0]));
                if (return_moto.Ok) {
                    console.log('return_moto successful, ID:', return_moto.Ok);
                    response = return_moto.Ok;
                } else {
                    console.error('return_moto failed:', return_moto.Err);
                    response = "fail";
                }

                break;
            case "returnTrack" :
                const return_track = await agentMotodex.return_track(parseInt(args[0]));
                if (return_track.Ok) {
                    console.log('return_track successful, ID:', return_track.Ok);
                    response = return_track.Ok;
                } else {
                    console.error('return_track failed:', return_track.Err);
                    response = "fail";
                }

                break;
            case "addHealthNFT" :
                await agentMotodex.add_health_nft(parseInt(args[0]), parseInt(args[1]));
                response = 'done';
                break;
            case "addHealthMoney" :
                value = await agentMotodex.value_in_main_coin(0)+ 10000n

                // Call the icrc2_approve() function
                approveArgs = {
                    fee: [],
                    memo: [],
                    from_subaccount: [],
                    created_at_time: [],
                    amount: value,
                    expected_allowance: [],
                    expires_at: [],
                    spender: {
                        owner: motoDEXprincipal, //i also tried the canisterId of the canister i launched
                        subaccount: [],
                    },
                };

                icrc2_approve = await agentICP.icrc2_approve(approveArgs);
                console.log(" icrc2_approve " + JSON.stringify(stringFrom(icrc2_approve)))
                if (icrc2_approve.Ok) {
                    console.log('Approve successful, transaction ID:', icrc2_approve.Ok);
                    await agentMotodex.add_health_money(parseInt(args[0]), value);
                } else {
                    console.error('Approve failed:', icrc2_approve.Err);
                    response = "fail";

                }

                break;
            case "updateCounter" :
                await agentMotodex.update_counter()
                response = "done"

                break;
            case "bidFor" :
                alert('Method is not added');
                // response = await concordiumBidFor(motoDexContract, String(args[0]),  String(args[1]), value);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }
    return response;
}

async function icpMethodCall(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;


    try {
        let url;
        let body;
        let response_fetch;
        let response_json;
        let payload;
        let r;
        let price_usd_array;
        let priceForTypeMoto;

        const host = (window.web3ChainId != 111111456327830)  ? 'http://127.0.0.1:4943' : 'https://icp-api.io';

        const agent = new window.HttpAgent({
            identity: window.identityICP,
            host ,
        });
        if (window.web3ChainId != 111111456327830) await agent.fetchRootKey()

        const agentMotodex = window.Actor.createActor(window.idlFactoryMotodex, {
            agent,
            canisterId: (window.web3ChainId != 111111456327830) ? "be2us-64aaa-aaaaa-qaabq-cai" : "6sjzu-nyaaa-aaaak-qihqa-cai"
        });

        const agentICP = window.Actor.createActor(window.idlFactoryICP, {
            agent,
            canisterId: "ryjl3-tyaaa-aaaaa-aaaba-cai"
        });

        switch (method) {
            case "getLimitsAndCounters" :
                response = [];
                break;
            case "balanceOf" :
                const motoDEXprincipal = window.Principal.fromText(args[0])
                const icrc1_balance_of = await agentICP.icrc1_balance_of({owner:motoDEXprincipal, subaccount:[]});

                response = icrc1_balance_of + '';

                break;
            case "tokenIdsAndOwners" :


                response = await agentMotodex.token_ids_and_owners([0],[10]) + ''
                break;
            case "getPriceForType" :


                response = await agentMotodex.get_price_for_type(parseInt(args[0])) + ''


                break;
            case "valueInMainCoin" :

                response = await agentMotodex.value_in_main_coin(parseInt(args[0])) + ''

                break;
            case "getTokenType" :

                response = await agentMotodex.get_token_type_nft(parseInt(args[0])) + ''

                break;
            case "getHealthForId" :

                response = await agentMotodex.get_token_health(parseInt(args[0])) + ''

                break;
            case "getPercentForTrack" :
                response = '30';//await concordiumGetPercentForTrack(motoDexContract, args[0]);
                break;
            case "getGameSessions" :

                response = [];//// response = await concordiumGetGameSessions(motoDexContract);
                break;
            case "getAllGameBids" :
                response = [];//await concordiumGetAllGameBids(motoDexContract);
                break;
            case "latestEpochUpdate" :
                response = "0"
                break;
            case "minimalFeeInUSD" :

                response_fetch = await agentMotodex.get_minimal_fee_usd()
                console.log('icpMethodCall ',response_fetch);

                response = response_fetch + ''

                break;
            case "getLatestPrice" :
                response = await agentMotodex.get_latest_price() + ''

                break;
            case "syncEpochResultsBidsFinal" :
                // response = await concordiumSyncEpochResultsBidsFinal(motoDexContract);
                break;
            case "syncEpochResultsMotosFinal" :
                // response = await concordiumSyncEpochResultsMotosFinal(motoDexContract);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }

    return response;
}

// ======== VARA

async function nibiruSendContract(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;
    let minimal_fee
    let coin_minimal_fee
    let funds
    try {
        switch (method) {
            case "purchase" :
                const value_in_main_coin =
                    await window.wasmClient.queryClient.wasm.queryContractSmart(
                        motoDexContract,
                        {
                            value_in_main_coin: { "type_nft":parseInt(args[0]) },
                        }
                    );
                console.log(" value_in_main_coin", value_in_main_coin);

                let coinResult = window.coin(value_in_main_coin.price + '', window.nibiruChainInfo.currencies[0].coinMinimalDenom);
                console.log(" coinResult", coinResult);
                funds = [coinResult];

                const contractExecutePurchase =
                    await wasmClient.execute(
                        web3gl.nibiruAccount,
                        motoDexContract,
                        {
                            //execution message
                            "purchase": { "type_nft":parseInt(args[0]), "extension":{} },
                        },
                        "auto",
                        "",
                        funds
                    );
                console.log(contractExecutePurchase);
                const events = contractExecutePurchase.events
                const execute = events[12]
                const token_id = execute.attributes[2]
                console.log("token_id",token_id.value);
                response = [token_id.value,"received"];
                break;
            case "addMoto" :
                minimal_fee =
                    await window.wasmClient.queryClient.wasm.queryContractSmart(
                        motoDexContract,
                        {
                            minimal_fee: { },
                        }
                    );
                console.log(" minimal_fee", minimal_fee);

                coin_minimal_fee = window.coin(minimal_fee.price + '', window.nibiruChainInfo.currencies[0].coinMinimalDenom);
                console.log(" coin_minimal_fee", coin_minimal_fee);
                funds = [coin_minimal_fee];

                const contractExecuteAddMoto =
                    await wasmClient.execute(
                        web3gl.nibiruAccount,
                        motoDexContract,
                        {
                            //execution message
                            "add_nft": { "token_id":args[0]},
                        },
                        "auto",
                        "",
                        funds
                    );
                console.log(contractExecuteAddMoto);
                response = "received";
                break;
            case "addTrack" :
                minimal_fee =
                    await window.wasmClient.queryClient.wasm.queryContractSmart(
                        motoDexContract,
                        {
                            minimal_fee: { },
                        }
                    );
                console.log(" minimal_fee", minimal_fee);

                coin_minimal_fee = window.coin(minimal_fee.price + '', window.nibiruChainInfo.currencies[0].coinMinimalDenom);
                console.log(" coin_minimal_fee", coin_minimal_fee);
                funds = [coin_minimal_fee];

                const contractExecuteAddTrack =
                    await wasmClient.execute(
                        web3gl.nibiruAccount,
                        motoDexContract,
                        {
                            //execution message
                            "add_nft": { "token_id":args[0]},
                        },
                        "auto",
                        "",
                        funds
                    );
                console.log(contractExecuteAddTrack);
                response = "received";
                break;
            case "returnMoto" :

                funds = [];

                const contractExecuteReturnMoto =
                    await wasmClient.execute(
                        web3gl.nibiruAccount,
                        motoDexContract,
                        {
                            //execution message
                            "return_nft": { "token_id":args[0]},
                        },
                        "auto",
                        "",
                        funds
                    );
                console.log(contractExecuteReturnMoto);
                response = "received";
                break;
            case "returnTrack" :

                funds = [];

                const contractExecuteReturnTrack =
                    await wasmClient.execute(
                        web3gl.nibiruAccount,
                        motoDexContract,
                        {
                            //execution message
                            "return_nft": { "token_id":args[0]},
                        },
                        "auto",
                        "",
                        funds
                    );
                console.log(contractExecuteReturnTrack);
                response = "received";
                break;
            case "addHealthNFT" :
                // response = await varaAddHealthNFT(motoDexContract, String(args[0]),  String(args[1]));
                funds = [];

                const contractExecuteAddHealthNFT =
                    await wasmClient.execute(
                        web3gl.nibiruAccount,
                        motoDexContract,
                        {
                            //execution message
                            "add_health_n_f_t": { "token_id":args[0], "health_pill_token_id":args[1]},
                        },
                        "auto",
                        "",
                        funds
                    );
                console.log(contractExecuteAddHealthNFT);
                response = "received";
                break;
            case "addHealthMoney" :
                // response = await varaAddHealthMoney(motoDexContract, String(args[0]));
                minimal_fee =
                    await window.wasmClient.queryClient.wasm.queryContractSmart(
                        motoDexContract,
                        {
                            minimal_fee: { },
                        }
                    );
                console.log(" minimal_fee", minimal_fee);

                coin_minimal_fee = window.coin(minimal_fee.price + '', window.nibiruChainInfo.currencies[0].coinMinimalDenom);
                console.log(" coin_minimal_fee", coin_minimal_fee);
                funds = [coin_minimal_fee];

                const contractExecuteAddHealthMoney =
                    await wasmClient.execute(
                        web3gl.nibiruAccount,
                        motoDexContract,
                        {
                            //execution message
                            "add_health_money": { "token_id":args[0], "attached_deposit":minimal_fee.price},
                        },
                        "auto",
                        "",
                        funds
                    );
                console.log(contractExecuteAddHealthMoney);
                response = "received";
                break;
            case "updateCounter" :
                // response = await varaUpdateCounter(motoDexContract);
                funds = [];

                const contractExecuteUpdateCounter =
                    await wasmClient.execute(
                        web3gl.nibiruAccount,
                        motoDexContract,
                        {
                            //execution message
                            "update_counter": { },
                        },
                        "auto",
                        "",
                        funds
                    );
                console.log(contractExecuteUpdateCounter);
                response = "received";
                break;
            case "bidFor" :
                alert('Method is not added');
                // response = await concordiumBidFor(motoDexContract, String(args[0]),  String(args[1]), value);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }
    return response;
}

async function nibiruMethodCall(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;

    try {
        switch (method) {
            case "getLimitsAndCounters" :
                response = [];
                break;
            case "balanceOf" :
                response = 0
                const balances = await window.signingClient.getAllBalances(web3gl.nibiruAccount)
                for (const balance in balances) {
                    if (balances[balance].denom === 'unibi') {
                        response = balances[balance].amount
                    }
                }
                // alert('Method is not added');

                break;
            case "tokenIdsAndOwners" :
                // response = [];
                alert('Method is not added');

                // response = JSON.parse(response);
                break;
            case "getPriceForType" :
                let get_price_for_type =
                    await window.wasmClient.queryClient.wasm.queryContractSmart(
                        motoDexContract,
                        {
                            get_price_for_type: { "type_nft":parseInt(args[0]) },
                        }
                    );
                console.log("get_price_for_type nibiru ",get_price_for_type);

                response = get_price_for_type.price + "";

                break;
            case "valueInMainCoin" :
                
                console.log("args[0]:", args[0]);
                console.log("motoDexContract:", motoDexContract);
                console.log("wasmClient:", window.wasmClient);
                
                let value_in_main_coin =
                    await window.wasmClient.queryClient.wasm.queryContractSmart(
                        motoDexContract,
                        {
                            value_in_main_coin: { "type_nft":parseInt(args[0]) },
                        }
                    );
                console.log("value_in_main_coin nibiru ",value_in_main_coin);

                response = value_in_main_coin.price + "";

                break;
            case "getTokenType" :
                alert('Method is not added');

                // response = await varaGetTokenTypeNFT(motoDexContract, args[0]);
                // response = JSON.parse(response);
                break;
            case "getHealthForId" :
                // alert('Method is not added');
                let get_token_health =
                    await window.wasmClient.queryClient.wasm.queryContractSmart(
                        motoDexContract,
                        {
                            token_health: { "token_id":args[0] },
                        }
                    );
                console.log("get_token_health nibiru ",get_token_health);

                response = get_token_health.value + "";

                break;
            case "getPercentForTrack" :
                response = '30';//await concordiumGetPercentForTrack(motoDexContract, args[0]);
                break;
            case "getGameSessions" :
                // response = await concordiumGetGameSessions(motoDexContract);
                response = [];
                break;
            case "getAllGameBids" :

                response = [];//await concordiumGetAllGameBids(motoDexContract);
                break;
            case "latestEpochUpdate" :
                // response = await concordiumLatestEpochUpdate(motoDexContract);
                break;
            case "minimalFeeInUSD" :
                let minimalFeeInUSD =
                    await window.wasmClient.queryClient.wasm.queryContractSmart(
                        motoDexContract,
                        {
                            minimal_fee: {},
                        }
                    );
                console.log("minimalFeeInUSD nibiru ",minimalFeeInUSD);

                response = minimalFeeInUSD.price + "";
                break;
            case "getLatestPrice" :
                response = "0";
                // alert('Method is not added');

                // response = await concordiumGetLatestPrice(motoDexContract);
                break;
            case "syncEpochResultsBidsFinal" :
                // alert('Method is not added');
                response = []
                // response = await concordiumSyncEpochResultsBidsFinal(motoDexContract);
                break;
            case "syncEpochResultsMotosFinal" :
                // alert('Method is not added');
                response = []

                // response = await concordiumSyncEpochResultsMotosFinal(motoDexContract);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }

    return response;
}

// ======== VARA

async function varaSendContract(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;
    try {
        switch (method) {
            case "purchase" :
                response = await varaPurchase(motoDexContract, parseInt(args[0]));
                break;
            case "addMoto" :
                response = await varaAddMoto(motoDexContract,  String(args[0]), true);
                break;
            case "addTrack" :
                response = await varaAddTrack(motoDexContract, String(args[0]), false);
                break;
            case "returnMoto" :
                response = await varaReturnMoto(motoDexContract, String(args[0]));
                break;
            case "returnTrack" :
                response = await varaReturnTrack(motoDexContract, String(args[0]));
                break;
            case "addHealthNFT" :
                response = await varaAddHealthNFT(motoDexContract, String(args[0]),  String(args[1]));
                break;
            case "addHealthMoney" :
                response = await varaAddHealthMoney(motoDexContract, String(args[0]));
                break;
            case "updateCounter" :
                response = await varaUpdateCounter(motoDexContract);
                break;
            case "bidFor" :
                alert('Method is not added');
                // response = await concordiumBidFor(motoDexContract, String(args[0]),  String(args[1]), value);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }
    return response;
}

async function varaMethodCall(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;

    try {
        switch (method) {
            case "getLimitsAndCounters" :
                // response = await concordiumTokenIdsAndOwners(motoDexContract);
                response = [];
                break;
            case "balanceOf" :
                response = await varaBalanceOf(motoDexContract, args[0]);
                break;
            case "tokenIdsAndOwners" :
                response = JSON.stringify(await varaTokenIdsAndOwners(motoDexContract));
                // response = JSON.parse(response);
                break;
            case "getPriceForType" :
                // response = await alephzeroGetPriceForType(motoDexContract, args[0]);
                response = await varaValueInMainCoin(motoDexContract, args[0]);

                break;
            case "valueInMainCoin" :
                response = await varaValueInMainCoin(motoDexContract, args[0]);
                response = JSON.parse(response);
                break;
            case "getTokenType" :
                response = await varaGetTokenTypeNFT(motoDexContract, args[0]);
                response = JSON.parse(response);
                break;
            case "getHealthForId" :
                response = await varaGetTokenHealth(motoDexContract, args[0]);
                response =  JSON.parse(response);
                break;
            case "getPercentForTrack" :
                response = '30';//await concordiumGetPercentForTrack(motoDexContract, args[0]);
                break;
            case "getGameSessions" :
                // response = await concordiumGetGameSessions(motoDexContract);
                response = [];
                break;
            case "getAllGameBids" :
                response = [];//await concordiumGetAllGameBids(motoDexContract);
                break;
            case "latestEpochUpdate" :
                response = await concordiumLatestEpochUpdate(motoDexContract);
                break;
            case "minimalFeeInUSD" :
                response = await varaGetMinimalFeeRate(motoDexContract);
                break;
            case "getLatestPrice" :
                response = await concordiumGetLatestPrice(motoDexContract);
                break;
            case "syncEpochResultsBidsFinal" :
                response = await concordiumSyncEpochResultsBidsFinal(motoDexContract);
                break;
            case "syncEpochResultsMotosFinal" :
                response = await concordiumSyncEpochResultsMotosFinal(motoDexContract);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }

    return response;
}
async function varaBalanceOf(motoDexContract, wallet) {
    console.log('varaBalanceOf window.varaConnectAccount ' +  window.varaConnectAccount + ' motoDexContract ' + motoDexContract);
    let metadata =  window.varaMetadata;
    let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet
    let result = await gearApi.programState.read({ programId: motoDexContract, payload: { OwnerTokensString: { owner: window.varaConnectAccount } }},metadata);
    console.log('varaBalanceOf result ' + result);
    let re = JSON.parse(result.toString());
    if (re.ownerTokensString === null) return "0"
    return re.ownerTokensString.length + ''
}

async function varaTokenIdsAndOwners(motoDexContract) {
    console.log('varaTokenIdsAndOwners window.varaConnectAccount ' +  window.varaConnectAccount + ' motoDexContract ' + motoDexContract);
    let metadata =  window.varaMetadata;
    let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

    let resultReceived = await gearApi.programState.read({ programId: motoDexContract, payload: { TokenIdsAndOwners: { } }},metadata);
    console.log('varaTokenIdsAndOwners resultReceived ' + resultReceived);
    let re = JSON.parse(resultReceived.toString());

    let outOk = re.tokenIdsAndOwners
    // console.log('callValue ',callValue);
    // if (result.isOk) {
    // output the return value
    let result = []

    for (let i = 0; i < outOk.length; i++) {
        let newObj = {}
        // {"trackTokenId":"","trackType":"","motoTokenId":"0","motoType":"RED_BULLER","ownerId":"5HE63d7VRe4BjofejBHXGNJnjKXNzEWyTVCZzpeuHebGhxTT","activeSession":""}
        for (const [key, value] of Object.entries(outOk[i])) {
            console.log("varaTokenIdsAndOwners " + key + "/" + value);
            // let finalValue = (value === null)
            if (key === "trackTokenId") newObj["track_token_id"] = value;
            if (key === "trackType") newObj["track_type"] = value;
            if (key === "motoTokenId") newObj["moto_token_id"] = value;
            if (key === "motoType") newObj["moto_type"] = value;
            if (key === "ownerId") newObj["owner_id"] = value;
            // if (value === null) outOk[i][key] = ""
        }
        result.push(newObj);
    }
    console.log('varaTokenIdsAndOwners result', result);

    // console.log('alephzeroTokenIdsAndOwners Success', out);
    // let outSting = JSON.stringify(out).replaceAll("null","");
    // let outFinal = JSON.parse(outSting)

    return result;
    // } else {
    //     console.error('alephzeroTokenIdsAndOwners Error', result.asErr);
    //
    // }
}


async function varaOwnersTokenByIndex(motoDexContract, index) {
    console.log('varaOwnersTokenByIndex window.varaConnectAccount ' +  window.varaConnectAccount + ' motoDexContract ' + motoDexContract);
    let metadata =  window.varaMetadata;
    let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

    let result = await gearApi.programState.read({ programId: motoDexContract, payload: { OwnersTokenByIndexString: { owner: window.varaConnectAccount, index: index} }},metadata);
    console.log('varaOwnersTokenByIndex result ' + result);
    let re = JSON.parse(result.toString());
    // if (re.ownersTokenByIndex.length === null) return "0"

    return re.ownersTokenByIndex
}

async function varaGetTokenTypeNFT(motoDexContract, tokenId) {
    console.log('varaGetTokenTypeNFT window.varaConnectAccount ' +  window.varaConnectAccount + ' motoDexContract ' + motoDexContract);
    let metadata =  window.varaMetadata;
    let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

    let result = await gearApi.programState.read({ programId: motoDexContract, payload: { TokenType: { token_id: tokenId} }},metadata);
    console.log('varaGetTokenTypeNFT result ' + result);
    let re = JSON.parse(result.toString());

    return re.tokenType
}

async function varaGetTokenHealth(motoDexContract, tokenId) {
    console.log('varaGetTokenHealth window.varaConnectAccount ' +  window.varaConnectAccount + ' motoDexContract ' + motoDexContract);
    let metadata =  window.varaMetadata;
    let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

    let result = await gearApi.programState.read({ programId: motoDexContract, payload: { TokenHealth: { token_id: tokenId} }},metadata);
    console.log('varaGetTokenHealth result ' + result);
    let re = JSON.parse(result.toString());

    return re.tokenHealth
}

async function varaGetPriceForType(motoDexContract, type) {
    console.log('varaGetPriceForType window.varaConnectAccount ' +  window.varaConnectAccount + ' motoDexContract ' + motoDexContract);
    let metadata =  window.varaMetadata;
    let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

    let result = await gearApi.programState.read({ programId: motoDexContract, payload: { PriceForType: { type_nft: type} }},metadata);
    console.log('varaGetPriceForType result ' + result);
    let re = JSON.parse(result.toString());

    return re.priceForType
}

async function varaValueInMainCoin(motoDexContract, type) {
    console.log('varaValueInMainCoin window.varaConnectAccount ' +  window.varaConnectAccount + ' motoDexContract ' + motoDexContract + ' type ' + type);
    let metadata =  window.varaMetadata;
    let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

    let result = await gearApi.programState.read({ programId: motoDexContract, payload: { ValueInMainCoin: { type_nft: type} }},metadata);
    console.log('varaValueInMainCoin result ' + result);
    let re = JSON.parse(result.toString());
    return re.valueInMainCoin
}

async function varaGetMinimalFeeRate(motoDexContract) {
    console.log('varaGetMinimalFeeRate window.varaConnectAccount ' +  window.varaConnectAccount + ' motoDexContract ' + motoDexContract);
    let metadata =  window.varaMetadata;
    let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

    let result = await gearApi.programState.read({ programId: motoDexContract, payload: { MinimalFeeRate: { } }},metadata);
    console.log('varaGetMinimalFeeRate result ' + result);
    let re = JSON.parse(result.toString());
    return re.minimalFeeRate
}

async function varaGetMinimalFee(motoDexContract) {
    console.log('varaGetMinimalFee window.varaConnectAccount ' +  window.varaConnectAccount + ' motoDexContract ' + motoDexContract);
    let metadata =  window.varaMetadata;
    let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

    let result = await gearApi.programState.read({ programId: motoDexContract, payload: { MinimalFee: { } }},metadata);
    console.log('varaGetMinimalFee result ' + result);
    let re = JSON.parse(result.toString());
    return re.minimalFee
}

async function varaAddMoto(motoDexContract, tokenId) {

    return new Promise(async function (resolve, reject)  {
        const minimal_fee = await varaGetMinimalFee(motoDexContract);
        console.log("varaAddMoto - minimal_fee " + minimal_fee);

        try {
            const message = {
                destination: motoDexContract, // programId
                payload: { AddMoto: { token_id: tokenId } },
                gasLimit: 100000000000,
                value: minimal_fee,
                // prepaid: true,
                // account: accountId,
                // if you send message with issued voucher
            };
            // In that case payload will be encoded using meta.types.handle.input type
            let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

            let extrinsic = gearApi.message.send(message, window.varaMetadata);
            console.log("varaAddMoto - extrinsic " + extrinsic);
            const firstAddressInjector = await window.web3FromAddress(window.varaConnectAccount)

            try {
                await extrinsic.signAndSend(window.varaConnectAccount, {signer: firstAddressInjector.signer}, (event) => {
                    console.log(event.toHuman());
                    if (event.status.isInBlock) {
                        console.log('in a block');
                    } else if (event.status.isFinalized) {
                        let ev = event.toHuman();
                        if (ev.dispatchError === undefined) {
                            console.log('finalized');
                            resolve("received");
                        } else {
                            reject(`Error ${JSON.stringify(ev.dispatchError)}`)
                        }

                    }
                });
            } catch (error) {
                console.error(`${error.name}: ${error.message}`);
                reject(`${error.name}: ${error.message}`)
            }
            // So if you want to use another type you can specify it
            // extrinsic = api.message.send(message, meta, meta.types.other.input);
        } catch (error) {
            console.error(`${error.name}: ${error.message}`);
            reject(`${error.name}: ${error.message}`)
        }
    });
}

async function varaAddTrack(motoDexContract, tokenId) {

    return new Promise(async function (resolve, reject)  {
        const minimal_fee = await varaGetMinimalFee(motoDexContract);
        try {
            const message = {
                destination: motoDexContract, // programId
                payload: { AddTrack: { token_id: tokenId } },
                gasLimit: 100000000000,
                value: minimal_fee,
                // prepaid: true,
                // account: accountId,
                // if you send message with issued voucher
            };
            // In that case payload will be encoded using meta.types.handle.input type
            let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

            let extrinsic = gearApi.message.send(message, window.varaMetadata);
            console.log("varaPurchase - extrinsic " + extrinsic);
            const firstAddressInjector = await window.web3FromAddress(window.varaConnectAccount)

            try {
                await extrinsic.signAndSend(window.varaConnectAccount, {signer: firstAddressInjector.signer}, (event) => {
                    console.log(event.toHuman());
                    if (event.status.isInBlock) {
                        console.log('in a block');
                    } else if (event.status.isFinalized) {
                        let ev = event.toHuman();
                        if (ev.dispatchError === undefined) {
                            console.log('finalized');
                            resolve("received");
                        } else {
                            reject(`Error ${JSON.stringify(ev.dispatchError)}`)
                        }

                    }
                });
            } catch (error) {
                console.error(`${error.name}: ${error.message}`);
                reject(`${error.name}: ${error.message}`)
            }
            // So if you want to use another type you can specify it
            // extrinsic = api.message.send(message, meta, meta.types.other.input);
        } catch (error) {
            console.error(`${error.name}: ${error.message}`);
            reject(`${error.name}: ${error.message}`)
        }
    });
}

async function varaReturnMoto(motoDexContract, tokenId) {

    return new Promise(async function (resolve, reject)  {
        try {
            const message = {
                destination: motoDexContract, // programId
                payload: { ReturnMoto: { token_id: tokenId } },
                gasLimit: 100000000000,
                // value: value,
                // prepaid: true,
                // account: accountId,
                // if you send message with issued voucher
            };
            // In that case payload will be encoded using meta.types.handle.input type
            console.log(window.gearApiTestnet);
            let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

            console.log(gearApi);
            let extrinsic = gearApi.message.send(message, window.varaMetadata);
            console.log("varaPurchase - extrinsic " + extrinsic);
            const firstAddressInjector = await window.web3FromAddress(window.varaConnectAccount)

            try {
                await extrinsic.signAndSend(window.varaConnectAccount, {signer: firstAddressInjector.signer}, (event) => {
                    console.log(event.toHuman());
                    if (event.status.isInBlock) {
                        console.log('in a block');
                    } else if (event.status.isFinalized) {
                        let ev = event.toHuman();
                        if (ev.dispatchError === undefined) {
                            console.log('finalized');
                            resolve("received");
                        } else {
                            reject(`Error ${JSON.stringify(ev.dispatchError)}`)
                        }

                    }
                });
            } catch (error) {
                console.error(`${error.name}: ${error.message}`);
                reject(`${error.name}: ${error.message}`)
            }
            // So if you want to use another type you can specify it
            // extrinsic = api.message.send(message, meta, meta.types.other.input);
        } catch (error) {
            console.log(error);            
            console.error(`${error.name}: ${error.message}`);
            reject(`${error.name}: ${error.message}`)
        }
    });
}

async function varaReturnTrack(motoDexContract, tokenId) {
    return new Promise(async function (resolve, reject)  {
        try {
            const message = {
                destination: motoDexContract, // programId
                payload: { ReturnTrack: { token_id: tokenId } },
                gasLimit: 100000000000,
                // value: value,
                // prepaid: true,
                // account: accountId,
                // if you send message with issued voucher
            };
            // In that case payload will be encoded using meta.types.handle.input type
            let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

            let extrinsic = gearApi.message.send(message, window.varaMetadata);
            console.log("varaPurchase - extrinsic " + extrinsic);
            const firstAddressInjector = await window.web3FromAddress(window.varaConnectAccount)

            try {
                await extrinsic.signAndSend(window.varaConnectAccount, {signer: firstAddressInjector.signer}, (event) => {
                    console.log(event.toHuman());
                    if (event.status.isInBlock) {
                        console.log('in a block');
                    } else if (event.status.isFinalized) {
                        let ev = event.toHuman();
                        if (ev.dispatchError === undefined) {
                            console.log('finalized');
                            resolve("received");
                        } else {
                            reject(`Error ${JSON.stringify(ev.dispatchError)}`)
                        }

                    }
                });
            } catch (error) {
                console.error(`${error.name}: ${error.message}`);
                reject(`${error.name}: ${error.message}`)
            }
            // So if you want to use another type you can specify it
            // extrinsic = api.message.send(message, meta, meta.types.other.input);
        } catch (error) {
            console.error(`${error.name}: ${error.message}`);
            reject(`${error.name}: ${error.message}`)
        }
    });
}

async function varaPurchase(motoDexContract, typeNft) {

    return new Promise(async function (resolve, reject)  {
        const value = parseInt(await varaValueInMainCoin(motoDexContract, typeNft) + '');
        const valueFloat = value / 10e11
        const valueFinal = Math.round(valueFloat) + 1;
        console.log('varaPurchase valueFinal ',value);

        try {
            const message = {
                destination: motoDexContract, // programId
                payload: { Purchase: { type_nft: typeNft } },
                gasLimit: 100000000000,
                value: value,
                // prepaid: true,
                // account: accountId,
                // if you send message with issued voucher
            };
            // In that case payload will be encoded using meta.types.handle.input type
            let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

            let extrinsic = gearApi.message.send(message, window.varaMetadata);
            console.log("varaPurchase - extrinsic " + extrinsic);
            const firstAddressInjector = await window.web3FromAddress(window.varaConnectAccount)

            try {
                await extrinsic.signAndSend(window.varaConnectAccount, {signer: firstAddressInjector.signer}, (event) => {
                    console.log(event.toHuman());
                    if (event.status.isInBlock) {
                        console.log('in a block');
                    } else if (event.status.isFinalized) {
                        let ev = event.toHuman();
                        if (ev.dispatchError === undefined) {
                            console.log('finalized');
                            resolve("received");
                        } else {
                            reject(`Error ${JSON.stringify(ev.dispatchError)}`)
                        }

                    }
                });
            } catch (error) {
                console.error(`${error.name}: ${error.message}`);
                reject(`${error.name}: ${error.message}`)
            }
            // So if you want to use another type you can specify it
            // extrinsic = api.message.send(message, meta, meta.types.other.input);
        } catch (error) {
            console.error(`${error.name}: ${error.message}`);
            reject(`${error.name}: ${error.message}`)
        }
    });
}

async function varaAddHealthNFT(motoDexContract, tokenId, healthTokenId) {
    return new Promise(async function (resolve, reject)  {
        try {
            const message = {
                destination: motoDexContract, // programId
                payload: { AddHealthNFT: { token_id: tokenId, health_pill_token_id: healthTokenId } },
                gasLimit: 100000000000,
                // value: minimal_fee_in_usd,
                // prepaid: true,
                // account: accountId,
                // if you send message with issued voucher
            };
            // In that case payload will be encoded using meta.types.handle.input type
            let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

            let extrinsic = gearApi.message.send(message, window.varaMetadata);
            console.log("varaAddHealthNFT - extrinsic " + extrinsic);
            const firstAddressInjector = await window.web3FromAddress(window.varaConnectAccount)

            try {
                await extrinsic.signAndSend(window.varaConnectAccount, {signer: firstAddressInjector.signer}, (event) => {
                    console.log(event.toHuman());
                    if (event.status.isInBlock) {
                        console.log('in a block');
                    } else if (event.status.isFinalized) {
                        let ev = event.toHuman();
                        if (ev.dispatchError === undefined) {
                            console.log('finalized');
                            resolve("received");
                        } else {
                            reject(`Error ${JSON.stringify(ev.dispatchError)}`)
                        }

                    }
                });
            } catch (error) {
                console.error(`${error.name}: ${error.message}`);
                reject(`${error.name}: ${error.message}`)
            }
            // So if you want to use another type you can specify it
            // extrinsic = api.message.send(message, meta, meta.types.other.input);
        } catch (error) {
            console.error(`${error.name}: ${error.message}`);
            reject(`${error.name}: ${error.message}`)
        }
    });
}

async function varaAddHealthMoney(motoDexContract, tokenId) {
    return new Promise(async function (resolve, reject)  {
        const minimal_fee = await varaGetMinimalFee(motoDexContract);
        try {
            const message = {
                destination: motoDexContract, // programId
                payload: { AddHealthMoney: { token_id: tokenId } },
                gasLimit: 100000000000,
                value: minimal_fee,
                // prepaid: true,
                // account: accountId,
                // if you send message with issued voucher
            };
            // In that case payload will be encoded using meta.types.handle.input type
            let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

            let extrinsic = gearApi.message.send(message, window.varaMetadata);
            console.log("varaAddHealthMoney - extrinsic " + extrinsic);
            const firstAddressInjector = await window.web3FromAddress(window.varaConnectAccount)

            try {
                await extrinsic.signAndSend(window.varaConnectAccount, {signer: firstAddressInjector.signer}, (event) => {
                    console.log(event.toHuman());
                    if (event.status.isInBlock) {
                        console.log('in a block');
                    } else if (event.status.isFinalized) {
                        let ev = event.toHuman();
                        if (ev.dispatchError === undefined) {
                            console.log('finalized');
                            resolve("received");
                        } else {
                            reject(`Error ${JSON.stringify(ev.dispatchError)}`)
                        }

                    }
                });
            } catch (error) {
                console.error(`${error.name}: ${error.message}`);
                reject(`${error.name}: ${error.message}`)
            }
            // So if you want to use another type you can specify it
            // extrinsic = api.message.send(message, meta, meta.types.other.input);
        } catch (error) {
            console.error(`${error.name}: ${error.message}`);
            reject(`${error.name}: ${error.message}`)
        }

    });
}

async function varaUpdateCounter(motoDexContract) {
    return new Promise(async function (resolve, reject)  {
        try {
            const message = {
                destination: motoDexContract, // programId
                payload: { UpdateCounter: {  } },
                gasLimit: 100000000000,
                // value: 0,
                // prepaid: true,
                // account: accountId,
                // if you send message with issued voucher
            };
            // In that case payload will be encoded using meta.types.handle.input type
            let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

            let extrinsic = gearApi.message.send(message, window.varaMetadata);
            console.log("varaUpdateCounter - extrinsic " + extrinsic);
            const firstAddressInjector = await window.web3FromAddress(window.varaConnectAccount)

            try {
                await extrinsic.signAndSend(window.varaConnectAccount, {signer: firstAddressInjector.signer}, (event) => {
                    console.log(event.toHuman());
                    if (event.status.isInBlock) {
                        console.log('in a block');
                    } else if (event.status.isFinalized) {
                        let ev = event.toHuman();
                        if (ev.dispatchError === undefined) {
                            console.log('finalized');
                            resolve("received");
                        } else {
                            reject(`Error ${JSON.stringify(ev.dispatchError)}`)
                        }

                    }
                });
            } catch (error) {
                console.error(`${error.name}: ${error.message}`);
                reject(`${error.name}: ${error.message}`)
            }
            // So if you want to use another type you can specify it
            // extrinsic = api.message.send(message, meta, meta.types.other.input);
        } catch (error) {
            console.error(`${error.name}: ${error.message}`);
            reject(`${error.name}: ${error.message}`)
        }

    });
}


async function varaAllNfts(motoDexContract, wallet) {
    let balance = await varaBalanceOf(motoDexContract, wallet);
    let balanceInt = parseInt(balance + '');
    let data = []

    while (balanceInt > 0) {
        let tokenId = await varaOwnersTokenByIndex(motoDexContract, balanceInt - 1);
        let tokenType = await varaGetTokenTypeNFT(motoDexContract, tokenId);
        let tokenPrice = await varaValueInMainCoin(motoDexContract, tokenType);
        let tokenHealth = await varaGetTokenHealth(motoDexContract, tokenType);

        let tokenTypeInt = parseInt(tokenType);
        // let motodex_type = "HealthPill"
        // if (tokenTypeInt => 100) motodex_type= "Track"
        // if (tokenTypeInt <= 6) motodex_type= "Moto"
        data.push({
            "contract": motoDexContract,
            "tokenId": tokenId,
            "uri": "https://openbisea.mypinata.cloud/ipfs/QmQWJNzPhyMSpaE6Wwaxry46AuAG1bpWrQoG3PpotLbjzY/red%20buller.gif",
            "balance" : "1",
            "currHealthWei" : tokenHealth,
            "maxHealthWei" : tokenPrice,
            "maxHealth" : 200000,
            "ItemData":{
                "name" : "",
                "description" : "",
                "image" : "https://openbisea.mypinata.cloud/ipfs/QmQWJNzPhyMSpaE6Wwaxry46AuAG1bpWrQoG3PpotLbjzY/red%20buller.gif",
                "type" : tokenTypeInt,
                "price" : 5,
            }
        });
        balanceInt--;
    }
    console.log("varaAllNfts - balance " + balance);
    console.log("varaAllNfts - data " + JSON.stringify(data));


    //data.push({"contract": nftUniV3ContractAddress, "tokenId": tokenID.toString(), "uri": tokenURI, "balance":"1"});


    return data;
}


async function alephzeroAllNfts(motoDexContract, wallet) {
    let balance = await alephzeroBalanceOf(motoDexContract, wallet);
    let balanceInt = parseInt(balance + '');
    let data = []

    while (balanceInt > 0) {
        let tokenId = await alephzeroOwnersTokenByIndex(motoDexContract, balanceInt - 1);
        let tokenType = await alephzeroGetTokenTypeNFT(motoDexContract, tokenId);
        let tokenPrice = await alephzeroValueInMainCoin(motoDexContract, tokenType);
        let tokenHealth = await alephzeroGetTokenHealth(motoDexContract, tokenType);

        let tokenTypeInt = parseInt(tokenType);
        // let motodex_type = "HealthPill"
        // if (tokenTypeInt => 100) motodex_type= "Track"
        // if (tokenTypeInt <= 6) motodex_type= "Moto"
        data.push({
            "contract": motoDexContract,
            "tokenId": tokenId,
            "uri": "https://openbisea.mypinata.cloud/ipfs/QmQWJNzPhyMSpaE6Wwaxry46AuAG1bpWrQoG3PpotLbjzY/red%20buller.gif",
            "balance" : "1",
            "currHealthWei" : tokenHealth,
            "maxHealthWei" : tokenPrice,
            "maxHealth" : 200000,
            "ItemData":{
                "name" : "",
                "description" : "",
                "image" : "https://openbisea.mypinata.cloud/ipfs/QmQWJNzPhyMSpaE6Wwaxry46AuAG1bpWrQoG3PpotLbjzY/red%20buller.gif",
                "type" : tokenTypeInt,
                "price" : 5,
            }
        });
        balanceInt--;
    }
    console.log("alephzeroAllNfts - balance " + balance);
    console.log("alephzeroAllNfts - data " + JSON.stringify(data));


    //data.push({"contract": nftUniV3ContractAddress, "tokenId": tokenID.toString(), "uri": tokenURI, "balance":"1"});


    return data;
}

async function alephzeroTokenIdsAndOwners(motoDexContract) {
    let storageDepositLimit = null;
    let { gasRequired, storageDeposit, result, output } =  await window.azcontract.query.tokenIdsAndOwners(
        window.azConnectAccount,
        {
            gasLimit : window.azGasLimit,
            storageDepositLimit,
        },
        "0",
        "0"
    );
    console.log(result.toHuman());
    console.log(gasRequired.toHuman());

    // console.log('callValue ',callValue);
    if (result.isOk) {
        // output the return value
        let out = output.toHuman()
        let outOk = out.Ok
        let result = []

        for (let i = 0; i < outOk.length; i++) {
            let newObj = {}
            // {"trackTokenId":"","trackType":"","motoTokenId":"0","motoType":"RED_BULLER","ownerId":"5HE63d7VRe4BjofejBHXGNJnjKXNzEWyTVCZzpeuHebGhxTT","activeSession":""}
            for (const [key, value] of Object.entries(outOk[i])) {
                console.log("alephzeroTokenIdsAndOwners " + key + "/" + value);
                // let finalValue = (value === null)
                if (key === "trackTokenId") newObj["track_token_id"] = value;
                if (key === "trackType") newObj["track_type"] = value;
                if (key === "motoTokenId") newObj["moto_token_id"] = value;
                if (key === "motoType") newObj["moto_type"] = value;
                if (key === "ownerId") newObj["owner_id"] = value;
                // if (value === null) outOk[i][key] = ""
            }
            result.push(newObj);
        }
        console.log('alephzeroTokenIdsAndOwners result', result);

        // console.log('alephzeroTokenIdsAndOwners Success', out);
        // let outSting = JSON.stringify(out).replaceAll("null","");
        // let outFinal = JSON.parse(outSting)

        return result;
    } else {
        console.error('alephzeroTokenIdsAndOwners Error', result.asErr);

    }
}
async function alephzeroBalanceOf(motoDexContract, wallet) {
    console.log('alephzeroBalanceOf window.azConnectAccount ', window.azConnectAccount);

    let storageDepositLimit = null;
    let { gasRequired, storageDeposit, result, output } =  await window.azcontract.query.balanceOf(
        window.azConnectAccount,
        {
            gasLimit : window.azGasLimit,
            storageDepositLimit,
        },
        window.azConnectAccount
    );
    console.log(result.toHuman());
    console.log(gasRequired.toHuman());

    // console.log('callValue ',callValue);
    if (result.isOk) {
        // output the return value
        let out = output.toHuman()
        console.log('Success', out);
        return out.Ok;
    } else {
        console.error('Error', result.asErr);
    }
    return "0"
}

async function alephzeroOwnersTokenByIndex(motoDexContract, index) {
    console.log('alephzeroOwnersTokenByIndex window.azConnectAccount ', window.azConnectAccount);


    let storageDepositLimit = null;
    let { gasRequired, storageDeposit, result, output } =  await window.azcontract.query.ownersTokenByIndex(
        window.azConnectAccount,
        {
            gasLimit : window.azGasLimit,
            storageDepositLimit,
        },
        window.azConnectAccount,
        index
    );
    console.log("alephzeroOwnersTokenByIndex ", result.toHuman());
    console.log("alephzeroOwnersTokenByIndex ",gasRequired.toHuman());

    // console.log('callValue ',callValue);
    if (result.isOk) {
        // output the return value
        let out = output.toHuman()
        console.log('alephzeroOwnersTokenByIndex Success', out);
        return out.Ok;
    } else {
        console.error('alephzeroOwnersTokenByIndex Error', result.asErr);
    }
    return "0"
}

async function alephzeroGetTokenTypeNFT(motoDexContract, tokenId) {
    console.log('alephzeroGetTokenTypeNFT window.azConnectAccount ', window.azConnectAccount);


    let storageDepositLimit = null;
    let { gasRequired, storageDeposit, result, output } =  await window.azcontract.query.getTokenTypeNft(
        window.azConnectAccount,
        {
            gasLimit : window.azGasLimit,
            storageDepositLimit,
        },
        tokenId,
    );
    console.log("alephzeroGetTokenTypeNFT ", result.toHuman());
    console.log("alephzeroGetTokenTypeNFT ",gasRequired.toHuman());

    // console.log('callValue ',callValue);
    if (result.isOk) {
        // output the return value
        let out = output.toHuman()
        console.log('alephzeroGetTokenTypeNFT Success', out);
        return out.Ok;
    } else {
        console.error('alephzeroGetTokenTypeNFT Error', result.asErr);
    }
    return "0"
}

async function alephzeroGetTokenHealth(motoDexContract, tokenId) {
    let storageDepositLimit = null;
    let { gasRequired, storageDeposit, result, output } =  await window.azcontract.query.getTokenHealth(
        window.azConnectAccount,
        {
            gasLimit : window.azGasLimit,
            storageDepositLimit,
        },
        tokenId
    );
    console.log(result.toHuman());
    console.log(gasRequired.toHuman());

    // console.log('callValue ',callValue);
    if (result.isOk) {
        // output the return value
        console.log('alephzeroGetTokenHealth Success', output.toHuman());
        let out = output.toHuman()

        return out.Ok.replaceAll(',','');
    } else {
        console.error('alephzeroGetTokenHealth Error', result.asErr);
    }
    return "0"
}

async function alephzeroGetPriceForType(motoDexContract, type) {
    let storageDepositLimit = null;
    let { gasRequired, storageDeposit, result, output } =  await window.azcontract.query.getPriceForType(
        window.azConnectAccount,
        {
            gasLimit : window.azGasLimit,
            storageDepositLimit,
        },
        type
    );
    console.log(result.toHuman());
    console.log(gasRequired.toHuman());

    // console.log('callValue ',callValue);
    if (result.isOk) {
        // output the return value
        console.log('alephzeroGetPriceForType Success', output.toHuman());
        let out = output.toHuman()

        return out.Ok.replaceAll(',','');
    } else {
        console.error('alephzeroGetPriceForType Error', result.asErr);
    }
    return "0"
}

async function alephzeroValueInMainCoin(motoDexContract, type) {
    let storageDepositLimit = null;
    let { gasRequired, storageDeposit, result, output } =  await window.azcontract.query.valueInMainCoin(
        window.azConnectAccount,
        {
            gasLimit : window.azGasLimit,
            storageDepositLimit,
        },
        type
    );
    console.log(result.toHuman());
    console.log(gasRequired.toHuman());

    // console.log('callValue ',callValue);
    if (result.isOk) {
        // output the return value
        console.log('alephzeroGetPriceForType Success', output.toHuman());
        let out = output.toHuman()
        return out.Ok.replaceAll(',','');
    } else {
        console.error('alephzeroGetPriceForType Error', result.asErr);
    }
    return "0"
}

async function alephzeroGetMinimalFeeRate(motoDexContract) {
    let storageDepositLimit = null;
    let { gasRequired, storageDeposit, result, output } =  await window.azcontract.query.getMinimalFeeRate(
        window.azConnectAccount,
        {
            gasLimit : window.azGasLimit,
            storageDepositLimit,
        }
    );
    console.log(result.toHuman());
    console.log(gasRequired.toHuman());

    // console.log('callValue ',callValue);
    if (result.isOk) {
        // output the return value
        console.log('alephzeroGetMinimalFeeRate Success', output.toHuman());
        let out = output.toHuman()
        return out.Ok.replaceAll(',','');
    } else {
        console.error('alephzeroGetMinimalFeeRate Error', result.asErr);
    }
    return "0"
}

async function alephzeroAddMoto(motoDexContract, tokenId) {

    return new Promise(async function (resolve, reject)  {
        const firstAddressInjector = await window.web3FromAddress(window.azConnectAccount)
        const minimal_fee_in_usd = await alephzeroGetMinimalFeeRate(motoDexContract);
        const big10 = new BN(10);
        const options = {
            value: window.azapi.registry.createType("Balance", minimal_fee_in_usd),
            gasLimit: window.azapi.registry.createType("WeightV2", { refTime: big10.pow(big10), proofSize: big10.pow(big10) }),
            storageDepositLimit: null,
        };
        await window.azcontract.tx
            .addMoto(options, tokenId)
            .signAndSend(window.azConnectAccount, {signer: firstAddressInjector.signer}, result => {
                if (result.status.isInBlock) {
                    console.log('in a block');
                } else if (result.status.isFinalized) {
                    console.log('finalized');
                    resolve("received");
                }
            });
    });
}

async function alephzeroAddTrack(motoDexContract, tokenId) {

    return new Promise(async function (resolve, reject)  {
        const firstAddressInjector = await window.web3FromAddress(window.azConnectAccount)
        const minimal_fee_in_usd = await alephzeroGetMinimalFeeRate(motoDexContract);
        const big10 = new BN(10);
        const options = {
            value: window.azapi.registry.createType("Balance", minimal_fee_in_usd),
            gasLimit: window.azapi.registry.createType("WeightV2", { refTime: big10.pow(big10), proofSize: big10.pow(big10) }),
            storageDepositLimit: null,
        };
        await window.azcontract.tx
            .addTrack(options, tokenId)
            .signAndSend(window.azConnectAccount, {signer: firstAddressInjector.signer}, result => {
                if (result.status.isInBlock) {
                    console.log('in a block');
                } else if (result.status.isFinalized) {
                    console.log('finalized');
                    resolve("received");
                }
            });
    });
}

async function alephzeroReturnMoto(motoDexContract, tokenId) {

    return new Promise(async function (resolve, reject)  {
        const firstAddressInjector = await window.web3FromAddress(window.azConnectAccount)
        const minimal_fee_in_usd = await alephzeroGetMinimalFeeRate(motoDexContract);
        const big10 = new BN(10);
        const options = {
            gasLimit: window.azapi.registry.createType("WeightV2", { refTime: big10.pow(big10), proofSize: big10.pow(big10) }),
            storageDepositLimit: null,
        };
        await window.azcontract.tx
            .returnMoto(options, tokenId)
            .signAndSend(window.azConnectAccount, {signer: firstAddressInjector.signer}, result => {
                if (result.status.isInBlock) {
                    console.log('in a block');
                } else if (result.status.isFinalized) {
                    console.log('finalized');
                    resolve("received");
                }
            });
    });
}

async function alephzeroReturnTrack(motoDexContract, tokenId) {
    return new Promise(async function (resolve, reject)  {
        const firstAddressInjector = await window.web3FromAddress(window.azConnectAccount)
        const minimal_fee_in_usd = await alephzeroGetMinimalFeeRate(motoDexContract);
        const big10 = new BN(10);
        const options = {
            gasLimit: window.azapi.registry.createType("WeightV2", { refTime: big10.pow(big10), proofSize: big10.pow(big10) }),
            storageDepositLimit: null,
        };
        await window.azcontract.tx
            .returnTrack(options, tokenId)
            .signAndSend(window.azConnectAccount, {signer: firstAddressInjector.signer}, result => {
                if (result.status.isInBlock) {
                    console.log('in a block');
                } else if (result.status.isFinalized) {
                    console.log('finalized');
                    resolve("received");
                }
            });
    });
}

async function alephzeroPurchase(motoDexContract, typeNft) {
    let storageDepositLimit = null;
    let { gasRequired, storageDeposit, result, output } =  await window.azcontract.query.totalSupply(
        window.azConnectAccount,
        {
            gasLimit : window.azGasLimit,
            storageDepositLimit,
        },
    );
    console.log(result.toHuman());
    console.log(gasRequired.toHuman());

    // console.log('callValue ',callValue);
    if (result.isOk) {
        // output the return value
        console.log('alephzeroPurchase Success', output.toHuman());

    } else {
        console.error('alephzeroPurchase Error', result.asErr);
    }

    return new Promise(async function (resolve, reject)  {
        const firstAddressInjector = await window.web3FromAddress(window.azConnectAccount)
        const value = parseInt(await alephzeroValueInMainCoin(motoDexContract, typeNft) + '');
        const valueFloat = value / 10e11
        const valueFinal = Math.round(valueFloat) + 1;
        console.log('alephzeroPurchase valueFinal ',valueFinal);
        const big10 = new BN(10);
        // const oneTzero = big10.pow(new BN(12));
        // const twelveTzero = oneTzero.muln(12);

        const options = {
            value: window.azapi.registry.createType("Balance", value),
            gasLimit: window.azapi.registry.createType("WeightV2", { refTime: big10.pow(big10), proofSize: big10.pow(big10) }),
            storageDepositLimit: null,
        };

        await window.azcontract.tx
            .purchase(options, typeNft)
            .signAndSend(window.azConnectAccount, {signer: firstAddressInjector.signer}, result => {
                if (result.status.isInBlock) {
                    console.log('alephzeroPurchase in a block');
                } else if (result.status.isFinalized) {
                    console.log('alephzeroPurchase result.txHash.toString()', result.txHash.toString());
                    console.log('alephzeroPurchase result.blockHash', result.status.asFinalized.toString());
                    console.log('alephzeroPurchase finalized output.toHuman().Ok ', output.toHuman().Ok);
                    resolve(result.txHash.toString() + ","+output.toHuman().Ok);
                }
            });
    });
}

async function alephzeroAddHealthNFT(motoDexContract, tokenId, healthTokenId) {
    return new Promise(async function (resolve, reject)  {
        const firstAddressInjector = await window.web3FromAddress(window.azConnectAccount)
        const big10 = new BN(10);
        const options = {
            gasLimit: window.azapi.registry.createType("WeightV2", { refTime: big10.pow(big10), proofSize: big10.pow(big10) }),
            storageDepositLimit: null,
        };
        await window.azcontract.tx
            .addHealthNFT(options, tokenId, healthTokenId)
            .signAndSend(window.azConnectAccount, {signer: firstAddressInjector.signer}, result => {
                if (result.status.isInBlock) {
                    console.log('in a block');
                } else if (result.status.isFinalized) {
                    console.log('finalized');
                    resolve("received");
                }
            });
    });
}

async function alephzeroAddHealthMoney(motoDexContract, tokenId) {
    return new Promise(async function (resolve, reject)  {
        const firstAddressInjector = await window.web3FromAddress(window.azConnectAccount)
        const minimal_fee_in_usd = await alephzeroGetMinimalFeeRate(motoDexContract);
        const big10 = new BN(10);
        const options = {
            value: window.azapi.registry.createType("Balance", minimal_fee_in_usd),
            gasLimit: window.azapi.registry.createType("WeightV2", { refTime: big10.pow(big10), proofSize: big10.pow(big10) }),
            storageDepositLimit: null,
        };
        await window.azcontract.tx
            .addHealthMoney(options, tokenId)
            .signAndSend(window.azConnectAccount, {signer: firstAddressInjector.signer}, result => {
                if (result.status.isInBlock) {
                    console.log('in a block');
                } else if (result.status.isFinalized) {
                    console.log('finalized');
                    resolve("received");
                }
            });
    });
}

async function alephzeroUpdateCounter(motoDexContract) {
    return new Promise(async function (resolve, reject)  {
        const firstAddressInjector = await window.web3FromAddress(window.azConnectAccount)
        const big10 = new BN(10);
        const options = {
            gasLimit: window.azapi.registry.createType("WeightV2", { refTime: big10.pow(big10), proofSize: big10.pow(big10) }),
            storageDepositLimit: null,
        };
        await window.azcontract.tx
            .updateCounter(options)
            .signAndSend(window.azConnectAccount, {signer: firstAddressInjector.signer}, result => {
                if (result.status.isInBlock) {
                    console.log('in a block');
                } else if (result.status.isFinalized) {
                    console.log('finalized');
                    resolve("received");
                }
            });
    });
}


async function alephzeroSendContract(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;
    try {
        switch (method) {
            case "purchase" :
                response = await alephzeroPurchase(motoDexContract, parseInt(args[0]));
                break;
            case "addMoto" :
                response = await alephzeroAddMoto(motoDexContract,  String(args[0]), true);
                break;
            case "addTrack" :
                response = await alephzeroAddTrack(motoDexContract, String(args[0]), false);
                break;
            case "returnMoto" :
                response = await alephzeroReturnMoto(motoDexContract, String(args[0]));
                break;
            case "returnTrack" :
                response = await alephzeroReturnTrack(motoDexContract, String(args[0]));
                break;
            case "addHealthNFT" :
                response = await alephzeroAddHealthNFT(motoDexContract, String(args[0]),  String(args[1]));
                break;
            case "addHealthMoney" :
                response = await alephzeroAddHealthMoney(motoDexContract, String(args[0]));
                break;
            case "updateCounter" :
                response = await alephzeroUpdateCounter(motoDexContract);
                break;
            case "bidFor" :
                alert('Method is not added');
                // response = await concordiumBidFor(motoDexContract, String(args[0]),  String(args[1]), value);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }
    return response;
}

async function alephzeroMethodCall(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;

    try {
        switch (method) {
            case "getLimitsAndCounters" :
                // response = await concordiumTokenIdsAndOwners(motoDexContract);
                response = [];
                break;
            case "balanceOf" :
                response = await alephzeroBalanceOf(motoDexContract, args[0]);
                break;
            case "tokenIdsAndOwners" :
                response = await alephzeroTokenIdsAndOwners(motoDexContract);
                break;
            case "getPriceForType" :
                // response = await alephzeroGetPriceForType(motoDexContract, args[0]);
                response = await alephzeroValueInMainCoin(motoDexContract, args[0]);

                break;
            case "valueInMainCoin" :
                response = await alephzeroValueInMainCoin(motoDexContract, args[0]);
                response = JSON.parse(response);
                break;
            case "getTokenType" :
                response = await alephzeroGetTokenTypeNFT(motoDexContract, args[0]);
                response = JSON.parse(response);
                break;
            case "getHealthForId" :
                response = await alephzeroGetTokenHealth(motoDexContract, args[0]);
                response =  JSON.parse(response);
                break;
            case "getPercentForTrack" :
                response = '30';//await concordiumGetPercentForTrack(motoDexContract, args[0]);
                break;
            case "getGameSessions" :
                response = await concordiumGetGameSessions(motoDexContract);
                break;
            case "getAllGameBids" :
                response = [];//await concordiumGetAllGameBids(motoDexContract);
                break;
            case "latestEpochUpdate" :
                response = await concordiumLatestEpochUpdate(motoDexContract);
                break;
            case "minimalFeeInUSD" :
                response = await alephzeroGetMinimalFeeRate(motoDexContract);
                break;
            case "getLatestPrice" :
                response = await concordiumGetLatestPrice(motoDexContract);
                break;
            case "syncEpochResultsBidsFinal" :
                response = await concordiumSyncEpochResultsBidsFinal(motoDexContract);
                break;
            case "syncEpochResultsMotosFinal" :
                response = await concordiumSyncEpochResultsMotosFinal(motoDexContract);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }

    return response;
}



async function methodCall(abi, nftUniV3ContractAddress, method, args, value) {
    console.log('methodCall method->',method);
    console.log('methodCall nftUniV3ContractAddress->',nftUniV3ContractAddress);
    console.log('methodCall window.web3ChainId->',window.web3ChainId)
    if (parseInt(window.web3ChainId) === 1698905757615031) {
        const motodexWeb3 = new Web3('https://motodex-1698905757615031-1.jsonrpc.testnet-sp1.sagarpc.io')
        const balanceOBS = parseInt(await motodexWeb3.eth.getBalance(walletAddress));
        if (balanceOBS === 0) {
            let response = await fetch('https://bot.openbisea.io/api/motodextestnet/' + walletAddress);

            if (response.ok) {
                console.log("balance result OK ");
            } else {
                console.log(" HTTP: " + response.status);
            }
        }
    }
    if (window.web3ChainId == 1111111456327825 || window.web3ChainId == 1111111456327830)
    {
        let response = await nibiruMethodCall(nftUniV3ContractAddress, method, args, value);
        // console.log(concResponse);

        if (typeof response != "string")
        {
            window.web3gl.methodCallResponse = JSON.stringify(response);
        }
        else
        {
            window.web3gl.methodCallResponse = response;
        }
        // console.log(window.web3gl.methodCallResponse);
        return;
    }

    if (window.web3ChainId == 1111456327825 || window.web3ChainId == 1111456327830)
    {
        let azResponse = await varaMethodCall(nftUniV3ContractAddress, method, args, value);
        // console.log(concResponse);

        if (typeof azResponse != "string")
        {
            window.web3gl.methodCallResponse = JSON.stringify(azResponse);
        }
        else
        {
            window.web3gl.methodCallResponse = azResponse;
        }
        // console.log(window.web3gl.methodCallResponse);
        return;
    }
    if (window.web3ChainId == 111456327825 || window.web3ChainId == 111456327830)
    {
        let aptosResponse = await aptosMethodCall(nftUniV3ContractAddress, method, args, value);
        // console.log(concResponse);

        if (typeof aptosResponse != "string")
        {
            window.web3gl.methodCallResponse = JSON.stringify(aptosResponse);
        }
        else
        {
            window.web3gl.methodCallResponse = aptosResponse;
        }
        // console.log(window.web3gl.methodCallResponse);
        return;
    }
    if (window.web3ChainId == 11111456327825 || window.web3ChainId == 11111456327830)
    {
        let aptosResponse = await suiMethodCall(nftUniV3ContractAddress, method, args, value);
        // console.log(concResponse);

        if (typeof aptosResponse != "string")
        {
            window.web3gl.methodCallResponse = JSON.stringify(aptosResponse);
        }
        else
        {
            window.web3gl.methodCallResponse = aptosResponse;
        }
        // console.log(window.web3gl.methodCallResponse);
        return;
    }
    if (window.web3ChainId == 111111456327825 || window.web3ChainId == 111111456327830)
    {
        let icpResponse = await icpMethodCall(nftUniV3ContractAddress, method, args, value);

        if (typeof icpResponse != "string")
        {
            window.web3gl.methodCallResponse = JSON.stringify(icpResponse);
        }
        else
        {
            window.web3gl.methodCallResponse = icpResponse;
        }
        // console.log(window.web3gl.methodCallResponse);
        return;
    }
    if (window.web3ChainId == 11456327825 || window.web3ChainId == 11456327830)
    {
        let azResponse = await alephzeroMethodCall(nftUniV3ContractAddress, method, args, value);
        // console.log(concResponse);

        if (typeof azResponse != "string")
        {
            window.web3gl.methodCallResponse = JSON.stringify(azResponse);
        }
        else
        {
            window.web3gl.methodCallResponse = azResponse;
        }
        // console.log(window.web3gl.methodCallResponse);
        return;
    }
    if (window.web3ChainId == 1456327825 || window.web3ChainId == 1456327830)
    {
        let concResponse = await concordiumMethodCall(nftUniV3ContractAddress, method, args, value);
        console.log(concResponse);

        if (typeof concResponse != "string")
        {
            window.web3gl.methodCallResponse = JSON.stringify(concResponse);
        }
        else
        {
            window.web3gl.methodCallResponse = concResponse;
        }
        console.log(window.web3gl.methodCallResponse);
        return;
    }
    console.log('methodCall args->',args);
    console.log('args->',args);

    // const responseV2 = await readContract({
    //     address: nftUniV3ContractAddress,
    //     abi: JSON.parse(abi),
    //     functionName: method,
    //     args: JSON.parse(args),
    // })

    // const final = JSON.parse(JSON.stringify(this, (key, value) =>
    //     typeof value === 'bigint'
    //         ? value.toString()
    //         : value // return everything else unchanged
    // ))
    // console.log('responseV2->',responseV2);
    // console.log('typeof responseV2->',typeof responseV2);
    // function toJson(data) {
    //     if (data !== undefined) {
    //         let intCount = 0, repCount = 0;
    //         const json = JSON.stringify(data, (_, v) => {
    //             if (typeof v === 'bigint') {
    //                 intCount++;
    //                 return `${v}#bigint`;
    //             }
    //             return v;
    //         });
    //         const res = json.replace(/"(-?\d+)#bigint"/g, (_, a) => {
    //             repCount++;
    //             return a;
    //         });
    //         if (repCount > intCount) {
    //             // You have a string somewhere that looks like "123#bigint";
    //             throw new Error(`BigInt serialization conflict with a string value.`);
    //         }
    //         return res;
    //     }
    // }
    // console.log('result toJson->',toJson(responseV2));
    // const back = JSON.parse(toJson(responseV2))
    // console.log('back toJson->',back);

    const account = getAccount()
    console.log('methodCall account->',account)
    const network = getNetwork()
    console.log('methodCall network->',network)
    console.log('methodCall web3gl.networkId->',web3gl.networkId)
    if (network !== undefined && network.chain !== undefined && network.chain.id !== parseInt(web3gl.networkId) ) {
        console.log('methodCall switch network to ',window.web3ChainId)

        await switchNetwork({
            chainId: window.web3ChainId,
        })
        const network = getNetwork()
        console.log('methodCall 2 network->',network)
    }

    try {
        let responseV2
        if (parseInt(window.web3ChainId) === 503129905 || parseInt(window.web3ChainId) === 1482601649) {
            // let ws = getWebSocketPublicClient;
            if (method === "valueInMainCoin") {
                if (window.ethereum) {
                    await window.ethereum.request({method: 'eth_requestAccounts'});
                    window.web3 = new Web3(window.ethereum);
                }
                const nft = new window.web3.eth.Contract(JSON.parse(abi), nftUniV3ContractAddress);
                const arsJson = JSON.parse(args)
                const type = await nft.methods.getTypeForId(arsJson[0]).call()
                responseV2 = parseInt(await nft.methods.getPriceForType(arsJson[0]).call())
                // responseV2 = await getWebSocketPublicClient().readContract({
                //     address: nftUniV3ContractAddress,
                //     abi: JSON.parse(abi),
                //     functionName: "getPriceForType",
                //     args: JSON.parse(args),
                // })
            } else {
                responseV2 = await getWebSocketPublicClient().readContract({
                    address: nftUniV3ContractAddress,
                    abi: JSON.parse(abi),
                    functionName: method,
                    args: JSON.parse(args),
                })
            }

        } else {
            responseV2 = await readContract({
                address: nftUniV3ContractAddress,
                abi: JSON.parse(abi),
                functionName: method,
                args: JSON.parse(args),
            })
        }

        if (method === 'getLatestPrice') {
            const r0 = responseV2[0];
            const r1 = responseV2[1];
            let response = {0:r0.toString(),1:r1.toString()}
            console.log('response->',response);
            window.web3gl.methodCallResponse = JSON.stringify(response);
        } else if (method === 'syncEpochResultsBidsFinal') {
            const r0 = responseV2[0];
            const r1 = responseV2[1];
            let list = []
            r0.forEach(function (obj) {
                const o = [
                    obj.amount.toString(),
                    obj.to.toString(),
                    obj.trackTokenId.toString(),
                    obj.motoTokenId.toString(),
                    obj.indexForDelete.toString(),
                    obj.receiverType.toString(),
                    obj.amountPlatform.toString()
                ]
                list.push(o)
            })
            let response = {0:list,1:r1.toString()}
            console.log('response->',response);
            window.web3gl.methodCallResponse = JSON.stringify(response);

        } else if (method === 'getAllGameBids') {
            const r0 = responseV2[0];
            const r1 = responseV2[1];
            let list = []
            r0.forEach(function (obj) {
                const o = [
                    obj.amount.toString(),
                    obj.trackId.toString(),
                    obj.motoId.toString(),
                    obj.timestamp.toString(),
                    obj.bidder.toString()
                ]
                list.push(o)
            })
            let response = {0:list,1:r1.toString()}
            console.log('response->',response);
            window.web3gl.methodCallResponse = JSON.stringify(response);

        } else if (method === 'getGameSessions') {
            const r0 = responseV2[0];
            const r1 = responseV2[1];
            let list = []
            r0.forEach(function (obj) {
                const o = [
                    obj.trackId.toString(),
                    obj.trackType.toString(),
                    obj.trackHealth.toString(),
                    obj.motoId.toString(),
                    obj.motoType.toString(),
                    obj.motoHealth.toString(),
                    obj.latestUpdateTime.toString(),
                    obj.latestTrackTimeResult.toString(),
                    obj.attempts.toString(),
                    obj.gameBidsSumTrack.toString()
                ]
                list.push(o)
            })
            let response = {0:list,1:r1.toString()}

            console.log('response->',response);
            window.web3gl.methodCallResponse = JSON.stringify(response);
        } else if (method === 'tokenIdsAndOwners') {
            let list = []
            const r0 = responseV2[0];
            const r1 = responseV2[1];
            r0.forEach(function (obj) {
                const o = [obj.trackTokenId.toString(),obj.trackType.toString(),obj.motoTokenId.toString(),obj.motoType.toString(),obj.owner.toString()]
                //     motoTokenId : obj.motoTokenId.toString(),
                //     motoType : obj.motoType.toString(),
                //     owner : obj.owner.toString(),
                //     trackTokenId : obj.trackTokenId.toString(),
                //     trackType : obj.trackType.toString()
                // }

                list.push(o)
            })
            let response = {0:list,1:r1.toString()}
            console.log('response->',response);
            window.web3gl.methodCallResponse = JSON.stringify(response);
        } else {

            console.log('response->' + toJson(responseV2)  + ' method ' + method);
            window.web3gl.methodCallResponse = toJson(responseV2);
        }
    } catch (e) {
        console.log('methodCall e->',JSON.stringify(e));

        // if (method === 'getLimitsAndCounters') {
        //     window.web3gl.methodCallResponse = []
        // } else {
        window.web3gl.methodCallResponse = "fail"
        // }

    }


    return
    const from = (await web3.eth.getAccounts())[0];
    const nftContract = new web3.eth.Contract(JSON.parse(abi), nftUniV3ContractAddress);
    let response;

    try {
        response = await nftContract.methods[method](...JSON.parse(args))
            .call({
                from,
                value: value ? value : undefined
            });
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }
    console.log(response);
    console.log(typeof response);
    if (typeof response != "string")
    {
        window.web3gl.methodCallResponse = JSON.stringify(response);
    }
    else
    {
        window.web3gl.methodCallResponse = response;
    }
    console.log(window.web3gl.methodCallResponse);
}

async function getTxStatus(transactionHash) {
    if (window.web3ChainId == 1111111456327825 || window.web3ChainId == 1111111456327830)
    {
        window.web3gl.getTxStatusResponse = "success"
        return;
    }
    if (window.web3ChainId == 1111456327825 || window.web3ChainId == 1111456327830)
    {
        window.web3gl.getTxStatusResponse = "success"
        return;
    }
    if (window.web3ChainId == 11456327825 || window.web3ChainId == 11456327830)
    {
        window.web3gl.getTxStatusResponse = "success"
        return;
    }
    if (window.web3ChainId == 111456327825 || window.web3ChainId == 111456327830)
    {
        window.web3gl.getTxStatusResponse = "success"
        return;
    }
    if (window.web3ChainId == 11111456327825 || window.web3ChainId == 11111456327830)
    {
        window.web3gl.getTxStatusResponse = "success"
        return;
    }
    if (window.web3ChainId == 111111456327825 || window.web3ChainId == 111111456327830)
    {
        window.web3gl.getTxStatusResponse = "success"
        return;
    }
    if (parseInt(window.web3ChainId) === 503129905 || parseInt(window.web3ChainId) === 1482601649) {
        let response;
        try {
            if (window.ethereum) {
                await window.ethereum.request({method: 'eth_requestAccounts'});
                window.web3 = new Web3(window.ethereum);
            }
            const from = (await window.web3.eth.getAccounts())[0];
            response = await window.web3.eth.getTransactionReceipt(transactionHash);
        } catch (error) {
            console.log("getTxStatus - " + error.message);
            response = "fail";
        }
        console.log(response);
        if (response.status == true)
        {
            response = "success"
        }
        else if (response.status == false)
        {
            response = "fail"
        }
        console.log(response);
        if (typeof response != "string")
        {
            window.web3gl.getTxStatusResponse = JSON.stringify(response);
        }
        else
        {
            window.web3gl.getTxStatusResponse = response;
        }
        return;
    }
    const transaction = await fetchTransaction({
        hash: transactionHash,
    })
    console.log("getTxStatus transaction - " + toJson(transaction));
    window.web3gl.getTxStatusResponse = "success"

    return
    let response;
    try {
        const from = (await web3.eth.getAccounts())[0];
        response = await web3.eth.getTransactionReceipt(transactionHash);
    } catch (error) {
        console.log("getTxStatus - " + error.message);
        response = "fail";
    }
    console.log(response);
    if (response.status == true)
    {
        response = "success"
    }
    else if (response.status == false)
    {
        response = "fail"
    }
    console.log(response);
    if (typeof response != "string")
    {
        window.web3gl.getTxStatusResponse = JSON.stringify(response);
    }
    else
    {
        window.web3gl.getTxStatusResponse = response;
    }
}

async function getBalance() {
    try {
        if (window.web3ChainId == 1111456327825 || window.web3ChainId == 1111456327830)
        {
            // VARA
            let gearApi = window.web3ChainId == 1111456327830 ? window.gearApiMainnet :  window.gearApiTestnet

            const { nonce, data: balance } = await gearApi.query.system.account(window.varaConnectAccount);
            const now = await gearApi.query.timestamp.now();
            console.log(`${now}: balance of ${balance.free} and a nonce of ${nonce}`);

            window.web3gl.getBalanceResponse = balance.free + ''
            return

        }
        if (window.web3ChainId == 111456327825 || window.web3ChainId == 111456327830)
        {
            let url = "https://fullnode.mainnet.aptoslabs.com/v1/accounts/" + window.aptosWalletAddress + "/resources"
            let response_fetch = await fetch(url, {
                method: "GET",
                headers: {
                    "Content-type": "application/json"
                }
            });
            let response_json = await response_fetch.json();
            let response = "fail";

            for (let i = 0; i < response_json.length; i++) {
                let value = response_json[i];
                if (value.type === '0x1::coin::CoinStore<0x1::aptos_coin::AptosCoin>') {
                    response = value.data.coin.value;
                }
            }
            window.web3gl.getBalanceResponse = response

            return

        }
        if (window.web3ChainId == 11111456327825 || window.web3ChainId == 11111456327830)
        {
            // https://fullnode.devnet.sui.io:443 https://fullnode.mainnet.sui.io:443
            let body = JSON.stringify({
                "jsonrpc": "2.0",
                "id": 1,
                "method": "suix_getBalance",
                "params": [
                    window.suiWalletAddress,
                    "0x2::sui::SUI"
                ]
            });


            let url = window.web3ChainId == 11111456327830 ? "https://fullnode.mainnet.sui.io:443" : "https://fullnode.devnet.sui.io:443"

            let response_fetch = await fetch(url, {
                method: "POST",
                body: body,
                headers: {
                    "Content-type": "application/json"
                }
            });
            let response_json = await response_fetch.json();
            let response = response_json.result.totalBalance;

            // for (let i = 0; i < response_json.result.length; i++) {
            //     let value = response_json.result[i];
            //     if (value.coinType === '0x2::sui::SUI') {
            //         response = parseInt(value.totalBalance);
            //     }
            // }
            window.web3gl.getBalanceResponse = response + ''

            return

        }
        if (parseInt(window.web3ChainId) === 1698905757615031) {
            const balanceOBS = parseInt(await window.web3.eth.getBalance(walletAddress));
            if (balanceOBS === 0) {
                let response = await fetch('https://bot.openbisea.io/api/motodextestnet/' + walletAddress);

                if (response.ok) {
                    console.log("balance result OK ");
                } else {
                    console.log(" HTTP: " + response.status);
                }
            }
        }
        if (parseInt(window.web3ChainId) === 503129905 || parseInt(window.web3ChainId) === 1482601649) {
            if (window.ethereum) {
                await window.ethereum.request({method: 'eth_requestAccounts'});
                window.web3 = new Web3(window.ethereum);
            }
            const usdc = new window.web3.eth.Contract(JSON.parse(usdcABI), parseInt(window.web3ChainId) === 503129905 ? "0x717d43399ab3a8aada669CDC9560a6BAfdeA9796" : "0xCC205196288B7A26f6D43bBD68AaA98dde97276d");
            const balanceOf = await usdc.methods.balanceOf(walletAddress).call();

            const balanceSfuel = parseInt(await window.web3.eth.getBalance(walletAddress));
            if (balanceSfuel === 0) {
                let response = await fetch('https://bot.openbisea.io/api/skale/' + walletAddress);

                if (response.ok) {
                    console.log("balance result OK ");
                } else {
                    console.log(" HTTP: " + response.status);
                }
            }
            // const balance = {formatted : "0.001"}
            //     await getWebSocketPublicClient().fetchBalance({
            //     address: walletAddress,
            //     formatUnits: 'ether',
            // })
            const balanceInt = balanceOf
            console.log("getBalance - " + balanceInt);

            window.web3gl.getBalanceResponse = balanceInt + ''
        } else {
            const balance = await fetchBalance({
                address: walletAddress,
                formatUnits: 'ether',
            })
            const balanceInt = Math.round(Number(balance.formatted) * 10 ** 18);
            //const balanceInt = parseFloat(balance.formatted) * 10e18
            console.log("getBalance - " + balanceInt);

            window.web3gl.getBalanceResponse = balanceInt + ''
        }
    } catch (error) {
        console.log("getBalance - " + error.message);
        response = "fail";
    }
    return

    let response;
    try {
        const from = (await web3.eth.getAccounts())[0];
        response = parseInt(await web3.eth.getBalance(from));
        //response = response * Math.pow(10, -18);
    } catch (error) {
        console.log("getBalance - " + error.message);
        response = "fail";
    }
    if (typeof response != "string")
    {
        window.web3gl.getBalanceResponse = JSON.stringify(response);
    }
    else
    {
        window.web3gl.getBalanceResponse = response;
    }
}

async function concrodiumSendContract(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;
    try {
        switch (method) {
            case "purchase" :
                response = await concordiumPurchase(motoDexContract, parseInt(args[0]));
                break;
            case "addMoto" :
                response = await concordiumAddNft(motoDexContract,  String(args[0]), true);
                break;
            case "addTrack" :
                response = await concordiumAddNft(motoDexContract, String(args[0]), false);
                break;
            case "returnMoto" :
                response = await concordiumReturnNft(motoDexContract, String(args[0]), true);
                break;
            case "returnTrack" :
                response = await concordiumReturnNft(motoDexContract, String(args[0]), false);
                break;
            case "addHealthNFT" :
                response = await concordiumAddHealthNftParams(motoDexContract, String(args[0]),  String(args[1]));
                break;
            case "addHealthMoney" :
                response = await concordiumAddHealthMoney(motoDexContract, String(args[0]));
                break;
            case "bidFor" :
                response = await concordiumBidFor(motoDexContract, String(args[0]),  String(args[1]), value);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }
    return response;
}

async function concordiumMethodCall(motoDexContract, method, args, value) {
    args = JSON.parse(args);
    console.log(args);
    console.log(args[0]);
    let response;
    try {
        switch (method) {
            case "tokenIdsAndOwners" :
                response = await concordiumTokenIdsAndOwners(motoDexContract);
                break;
            case "getPriceForType" :
                response = await concordiumValueInMainCoin(motoDexContract, parseInt(args[0]));
                response = JSON.parse(response);
                break;
            case "valueInMainCoin" :
                response = await concordiumValueInMainCoin(motoDexContract, parseInt(args[0]));
                response = JSON.parse(response);
                break;
            case "getTokenType" :
                response = await concordiumGetTokenTypeId(motoDexContract, args[0]);
                response = JSON.parse(response);
                break;
            case "getHealthForId" :
                response = await concordiumGetTokenHealth(motoDexContract, args[0]);
                response =  JSON.parse(response);
                break;
            case "getPercentForTrack" :
                response = await concordiumGetPercentForTrack(motoDexContract, args[0]);
                break;
            case "getGameSessions" :
                response = await concordiumGetGameSessions(motoDexContract);
                break;
            case "getAllGameBids" :
                response = await concordiumGetAllGameBids(motoDexContract);
                break;
            case "latestEpochUpdate" :
                response = await concordiumLatestEpochUpdate(motoDexContract);
                break;
            case "minimalFeeInUSD" :
                response = await concordiumMinimalFeeInUSD(motoDexContract);
                break;
            case "getLatestPrice" :
                response = await concordiumGetLatestPrice(motoDexContract);
                break;
            case "syncEpochResultsBidsFinal" :
                response = await concordiumSyncEpochResultsBidsFinal(motoDexContract);
                break;
            case "syncEpochResultsMotosFinal" :
                response = await concordiumSyncEpochResultsMotosFinal(motoDexContract);
                break;
            default:
                alert('Method is not added');
        }
    }catch (error) {
        console.log(method + " - " + error.message);
        response = "fail";
    }

    return response;
}

async function connectConcordiumWallet(mainnet, routeBackURL) {
    console.log("Connecting to CCD... mainnet " + mainnet);
    const provider = await concordiumHelpers.detectConcordiumProvider();
    provider.rpcClientConfig = {
        ...provider.rpcClientConfig,
        network: 'testnet'
    };
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const consensusStatus = await client.getConsensusStatus();
    const lastFinalizedBlock = await consensusStatus.lastFinalizedBlock;
    console.log("Connecting to CCD... lastFinalizedBlock " + lastFinalizedBlock);
    const acct = { credId: accountAddress };//new concordiumSDK.AccountAddress(accountAddress);
    console.log("Connecting to CCD... acct " + JSON.stringify(acct));

    // const accountInfo = await client.getAccountInfo(acct);
    // console.log("Connecting to CCD... accountInfo.accountAmount " + accountInfo.accountAmount);
    // const accountAmount = accountInfo.accountAmount;
    return accountAddress;
}

async function concordiumTokenIdsAndOwners(motoDexContract) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'tokenIdsAndOwners';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const parameters = {
        "from_index":{"None":[]},
        "limit":{"None":[]}
    };

    const inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName,
            parameter: inputParams
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue.length == 0) returnValue = "";
    if (returnValue == ""){
        console.log(returnValue);
        return returnValue;
    }
    let structData = [];
    for (let i = 0; i < returnValue.length; i++) {
        const trackTokenID = returnValue[i].track_token_id.Some ? returnValue[i].track_token_id.Some[0] : "115792089237316195423570985008687907853269984665640564039457584007913129639935";
        const trackType = returnValue[i].track_type.Some ? returnValue[i].track_type.Some[0] : "255";
        const motoTokenID = returnValue[i].moto_token_id.Some ? returnValue[i].moto_token_id.Some[0] : "115792089237316195423570985008687907853269984665640564039457584007913129639935";
        const motoType = returnValue[i].moto_type.Some ? returnValue[i].moto_type.Some[0] : "255";
        const owner = returnValue[i].owner_id.Account[0];
        structData.splice(i, 0, [trackTokenID, trackType, motoTokenID, motoType, owner]);
    }
    let fullStructData = {"0":structData, "1":String(returnValue.length)};
    console.log(fullStructData);
    return fullStructData;
}

async function concordiumNftTokensForOwners(motoDexContract) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'nftTokensForOwners';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const parameters = {
        "address":{"Account":[accountAddress]},
        "from_index": {"None":[]},
        "limit": {"None":[]}
    };

    const inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName,
            parameter: inputParams
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == ""){
        return returnValue;
    }
    let structData = [];
    for (let i = 0; i < returnValue.length; i++) {
        const tokenID = returnValue[i].token_id;
        const tokenURI = returnValue[i].metadata.uri;
        const name = returnValue[i].metadata.name;
        const typeNft = returnValue[i].metadata.type_nft;
        structData.push({"contract": motoDexContract, "tokenId": tokenID, "uri": tokenURI, "balance":"1", "ItemData": {"name": name, "type": typeNft}});
    }
    console.log(structData);
    return structData;
}

async function concordiumLatestEpochUpdate(motoDexContract) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'view'; // Temporary
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = 0;
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
        returnValue = returnValue.latest_epoch_update;
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == 0){
        return returnValue;
    }
    return returnValue;
}

async function concordiumGetLatestPrice(motoDexContract) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'getLatestPrice';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "[]";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
        returnValue = '{"0":"' + returnValue + '","1":"1"}'
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == "[]"){
        return returnValue;
    }

    return returnValue;
}

async function concordiumSyncEpochResultsBidsFinal(motoDexContract) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'syncEpochResultsBidsFinal';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "[]";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == "[]"){
        return returnValue;
    }
    // let structData = {"0":[],"1":String(returnValue.length)};
    // for (let i = 0; i < returnValue.length; i++) {
    //   const amount = returnValue[i].amount;
    //   const trackId = returnValue[i].track_token_id;
    //   const motoId = returnValue[i].moto_token_id;
    //   const timestamp = returnValue[i].timestamp;
    //   const bidder = returnValue[i].bidder.Account[0];
    //   structData["0"].push([amount, trackId, motoId, timestamp, bidder]);
    // }
    // console.log(structData);
    return returnValue; // structData;
}

async function concordiumSyncEpochResultsMotosFinal(motoDexContract) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'syncEpochResultsMotosFinal';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "[]";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == "[]"){
        return returnValue;
    }
    // let structData = {"0":[],"1":String(returnValue.length)};
    // for (let i = 0; i < returnValue.length; i++) {
    //   const amount = returnValue[i].amount;
    //   const trackId = returnValue[i].track_token_id;
    //   const motoId = returnValue[i].moto_token_id;
    //   const timestamp = returnValue[i].timestamp;
    //   const bidder = returnValue[i].bidder.Account[0];
    //   structData["0"].push([amount, trackId, motoId, timestamp, bidder]);
    // }
    // console.log(structData);
    return returnValue; // structData;
}

async function concordiumGetTokenHealth(motoDexContract, tokenId) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'getTokenHealth';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const parameters = {
        "token_id":tokenId // String
    };

    const inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName,
            parameter: inputParams
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == ""){
        return returnValue;
    }
    console.log(returnValue);
    return returnValue;
}

async function concordiumValueInMainCoin(motoDexContract, typeNft) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'valueInMainCoin';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const parameters = {
        "type_nft":typeNft // Int
    };

    const inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName,
            parameter: inputParams
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == ""){
        return returnValue;
    }
    console.log(returnValue);
    return returnValue;
}

async function concordiumGetPercentForTrack(motoDexContract, tokenId) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'getPercentForTrack';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const parameters = {
        "token_id":tokenId // String
    };

    const inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName,
            parameter: inputParams
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == ""){
        return returnValue;
    }
    console.log(returnValue);
    return returnValue;
}

async function concordiumGetGameSessions(motoDexContract, tokenId) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'getSessions';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    console.log(result);
    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "[]";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == "[]"){
        return returnValue;
    }
    console.log(returnValue);
    return returnValue;
}

async function concordiumGetAllGameBids(motoDexContract, tokenId) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'getBids';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "[]";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == "[]"){
        return returnValue;
    }
    let structData = {"0":[],"1":String(returnValue.length)};
    for (let i = 0; i < returnValue.length; i++) {
        const amount = returnValue[i].amount;
        const trackId = returnValue[i].track_token_id;
        const motoId = returnValue[i].moto_token_id;
        const timestamp = returnValue[i].timestamp;
        const bidder = returnValue[i].bidder.Account[0];
        structData["0"].push([amount, trackId, motoId, timestamp, bidder]);
    }
    console.log(structData);
    return structData;
}

async function concordiumGetTokenTypeId(motoDexContract, tokenId) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'getTokenTypeId';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    console.log(typeof(tokenId) + " " + tokenId)
    const parameters = {
        "token_id":tokenId // String
    };

    const inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName,
            parameter: inputParams
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    if (returnValue == ""){
        return returnValue;
    }
    console.log(returnValue);
    return returnValue;
}

async function concordiumMinimalFeeInUSD(motoDexContract) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const contractName = motoDexContract.split(":")[0];
    const receiveFunctionName = 'view';
    const methodName = contractName + '.' + receiveFunctionName;

    var moduleFileBuffer = new Buffer(bin64, 'base64');

    const result = await client.invokeContract(
        {
            invoker: new concordiumSDK.AccountAddress(accountAddress),
            contract: contractAddress,
            method: methodName
        }
    );

    console.log(result);
    if (result.returnValue == undefined) result.returnValue = "";

    const rawReturnValue = Buffer.from(result.returnValue, 'hex');
    console.log(rawReturnValue);
    const schema = moduleFileBuffer; // Load schema from file
    const schemaVersion = concordiumSDK.SchemaVersion.V1;
    let returnValue = "";
    try{
        returnValue = concordiumSDK.deserializeReceiveReturnValue(rawReturnValue, schema, contractName, receiveFunctionName, schemaVersion);
        returnValue = returnValue.min_fee * 1e6 / returnValue.price_main_coin_usd;
    }
    catch (error) {
        console.log(methodName + error.message);
    }
    console.log(returnValue);
    return returnValue;
}


async function concordiumPurchase(motoDexContract, typeNft) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const instanceInfo = await client.getInstanceInfo(
        contractAddress);

    const contractName = motoDexContract.split(":")[0];
    let receiveFunctionName = 'purchase';
    let methodName = contractName + '.' + receiveFunctionName;
    const moduleFileBuffer = new Buffer(bin64, 'base64');
    const parameters = {
        "referral":{"None":[]},
        "type_nft": typeNft // Int
    };
    let inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    const value_in_main_coin = await concordiumValueInMainCoin(motoDexContract, typeNft);
    console.log("value_in_main_coin - " + value_in_main_coin)
    const amount = { microGtuAmount: BigInt(value_in_main_coin) };

    const txHash = await provider.sendTransaction(
        accountAddress,
        concordiumSDK.AccountTransactionType.Update,
        {
            amount: amount,
            contractAddress: contractAddress,
            receiveName: methodName,
            maxContractExecutionEnergy: 30000n,
            parameters: inputParams,
        },
        parameters,
        bin64
    );
    const txStatus = await concordiumCheckTransactionStatus(txHash, client)
    if ( txStatus == "success" ){
        await sleep(5000);
        window.location.reload();
    }
    return txStatus;
}

async function concordiumAddHealthMoney(motoDexContract, tokenId) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const instanceInfo = await client.getInstanceInfo(
        contractAddress);

    const contractName = motoDexContract.split(":")[0];
    let receiveFunctionName = 'addHealthMoney';
    let methodName = contractName + '.' + receiveFunctionName;
    const moduleFileBuffer = new Buffer(bin64, 'base64');
    const parameters = {
        "token_id":tokenId // String
    };
    let inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    const typeNft = await concordiumGetTokenTypeId(motoDexContract, tokenId);
    const value_in_main_coin = await concordiumValueInMainCoin(motoDexContract, typeNft);
    const amount = { microGtuAmount: BigInt(value_in_main_coin) };

    const txHash = await provider.sendTransaction(
        accountAddress,
        concordiumSDK.AccountTransactionType.Update,
        {
            amount: amount,
            contractAddress: contractAddress,
            receiveName: methodName,
            maxContractExecutionEnergy: 30000n,
            parameters: inputParams,
        },
        parameters,
        bin64
    );
    const txStatus = await concordiumCheckTransactionStatus(txHash, client)
    return txStatus;
}

async function concordiumBidFor(motoDexContract, trackTokenId, motoTokenId, value) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const instanceInfo = await client.getInstanceInfo(
        contractAddress);

    const contractName = motoDexContract.split(":")[0];
    let receiveFunctionName = 'bidFor';
    let methodName = contractName + '.' + receiveFunctionName;
    const moduleFileBuffer = new Buffer(bin64, 'base64');
    const parameters = {
        "track_token_id": trackTokenId, // String
        "moto_token_id": motoTokenId // String
    };
    let inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    if (value == null || value == "0") value = "1";
    //const value_in_main_coin = await concordiumValueInMainCoin(motoDexContract, typeNft);
    const amount = { microGtuAmount: BigInt(value) };

    const txHash = await provider.sendTransaction(
        accountAddress,
        concordiumSDK.AccountTransactionType.Update,
        {
            amount: amount,
            contractAddress: contractAddress,
            receiveName: methodName,
            maxContractExecutionEnergy: 30000n,
            parameters: inputParams,
        },
        parameters,
        bin64
    );
    const txStatus = await concordiumCheckTransactionStatus(txHash, client)
    return txStatus;
}

async function concordiumAddHealthNftParams(motoDexContract, tokenId, healthPillTokenId) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const instanceInfo = await client.getInstanceInfo(
        contractAddress);

    const contractName = motoDexContract.split(":")[0];
    let receiveFunctionName = 'addHealthNft';
    let methodName = contractName + '.' + receiveFunctionName;
    const moduleFileBuffer = new Buffer(bin64, 'base64');
    const parameters = {
        "token_id": tokenId, // String
        "health_pill_token_id": healthPillTokenId, // String
        "amount": "1",
        "owner":{"Account":[accountAddress]},
    };
    let inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    //const value_in_main_coin = await concordiumValueInMainCoin(motoDexContract, typeNft);
    const amount = { microGtuAmount: BigInt(1) };

    const txHash = await provider.sendTransaction(
        accountAddress,
        concordiumSDK.AccountTransactionType.Update,
        {
            amount: amount,
            contractAddress: contractAddress,
            receiveName: methodName,
            maxContractExecutionEnergy: 30000n,
            parameters: inputParams,
        },
        parameters,
        bin64
    );
    const txStatus = await concordiumCheckTransactionStatus(txHash, client)
    return txStatus;
}

async function concordiumAddNft(motoDexContract, tokenId, isMoto) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const instanceInfo = await client.getInstanceInfo(
        contractAddress);

    const contractName = motoDexContract.split(":")[0];
    let receiveFunctionName = isMoto ? 'addMoto' : "addTrack";
    let methodName = contractName + '.' + receiveFunctionName;
    const moduleFileBuffer = new Buffer(bin64, 'base64');
    const parameters = {
        "token_id":tokenId, // String
        "previous_owner":{"Account":[accountAddress]},
    };
    let inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    const minimal_fee_in_usd = await concordiumMinimalFeeInUSD(motoDexContract);
    const amount = { microGtuAmount: BigInt(minimal_fee_in_usd) };
    //const amount = { microGtuAmount:  200000000n };

    const txHash = await provider.sendTransaction(
        accountAddress,
        concordiumSDK.AccountTransactionType.Update,
        {
            amount: amount,
            contractAddress: contractAddress,
            receiveName: methodName,
            maxContractExecutionEnergy: 30000n,
            parameters: inputParams,
        },
        parameters,
        bin64
    );
    const txStatus = await concordiumCheckTransactionStatus(txHash, client)
    return txStatus;
}

async function concordiumReturnNft(motoDexContract, tokenId, isMoto) {
    const provider = await concordiumHelpers.detectConcordiumProvider();
    const accountAddress = await provider.connect();
    console.log("Connecting to CCD... accountAddress " + accountAddress);
    const client = await provider.getGrpcClient();
    const contractAddress = {
        subindex: 0n,
        index: BigInt(motoDexContract.split(":")[1]),
    };

    const instanceInfo = await client.getInstanceInfo(
        contractAddress);

    const contractName = motoDexContract.split(":")[0];
    let receiveFunctionName = isMoto ? 'returnMoto' : "returnTrack";
    let methodName = contractName + '.' + receiveFunctionName;
    const moduleFileBuffer = new Buffer(bin64, 'base64');
    const parameters = {
        "token_id":tokenId, // String
        "new_owner":{"Account":[accountAddress]},
    };
    let inputParams = concordiumSDK.serializeUpdateContractParameters(
        contractName,
        receiveFunctionName,
        parameters,
        moduleFileBuffer,
        0
    );

    const amount = { microGtuAmount: BigInt(0) };

    const txHash = await provider.sendTransaction(
        accountAddress,
        concordiumSDK.AccountTransactionType.Update,
        {
            amount: amount,
            contractAddress: contractAddress,
            receiveName: methodName,
            maxContractExecutionEnergy: 30000n,
            parameters: inputParams,
        },
        parameters,
        bin64
    );
    const txStatus = await concordiumCheckTransactionStatus(txHash, client)
    return txStatus;
}

async function connectNearWallet(mainnet, routeBackURL) {
    console.log("Connecting to NEAR... network " + mainnet);
    mainnet = await checkNetwork(mainnet);
    console.log("Connecting mainnet " + mainnet);

    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://testnet.mynearwallet.com/'
    });
    console.log("NEAR object created: ", near);

    const wallet = new nearApi.WalletConnection(near, 'OpenBiSea');
    console.log("WalletConnection object created: ", wallet);

    const successUrl = (routeBackURL !== undefined) ? routeBackURL : window.location.href;
    console.log("Success URL: ", successUrl);

    if(!wallet.isSignedIn())
        await wallet.requestSignIn({
            title:'motoDEX',
            successUrl: successUrl,
            failureUrl: (routeBackURL !== undefined) ? routeBackURL : window.location.href
        });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");
    console.log("Near Wallet: " + JSON.parse(account.connection.signer.keyStore.localStorage.OpenBiSea_wallet_auth_key).accountId);
    window.web3gl.connectNearWalletAccount = JSON.parse(account.connection.signer.keyStore.localStorage.OpenBiSea_wallet_auth_key).accountId;
    return wallet;
}

async function nearGetPriceForType(mainnet, motoDexContract, type) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["value_in_main_coin", "get_price_for_type"], // view methods do not change state but usually return a value
            sender: account, // account object to initialize and sign transactions.
        }
    );
    // console.log("contract " + contract);

    const value_in_main_coin = await contract.value_in_main_coin({ type_nft: parseInt(type) });
    const value_in_main_coin_float = parseFloat(value_in_main_coin) * 1.02;
    const value_in_main_coinFull = eToNumber(value_in_main_coin_float.toLocaleString('fullwide', {useGrouping:false}));

    const get_price_for_type = await contract.get_price_for_type({ type_nft: parseInt(type) });
    const get_price_for_typeFull = eToNumber(get_price_for_type.toLocaleString('fullwide', {useGrouping:false}));
    console.log("nearGetPriceForType value_in_main_coinFull " + value_in_main_coinFull + ' get_price_for_typeFull ' + get_price_for_typeFull + " motoDexContract " + motoDexContract);
    return JSON.stringify({value_in_main_coin: value_in_main_coinFull, value_in_main_coin_correct: value_in_main_coin, get_price_for_type: get_price_for_typeFull});
}

async function nearMinimalFeeInUSD(mainnet, motoDexContract) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["get_minimal_fee", "value_in_main_coin"], // view methods do not change state but usually return a value
            sender: account, // account object to initialize and sign transactions.
        }
    );
    // console.log("contract " + contract);

    console.log("nearMinimalFeeInUSD motoDexContract: " + motoDexContract);
    let minimal_fee_in_usd = await contract.get_minimal_fee();
    console.log(minimal_fee_in_usd);

    // const value_in_main_coin = await contract.value_in_main_coin({ type_nft: parseInt(minimal_fee_in_usd) });
    // const value_in_main_coin_float = parseFloat(value_in_main_coin) * 1.001;
    // const value_in_main_coinFull = eToNumber(value_in_main_coin_float.toLocaleString('fullwide', {useGrouping:false}));
    //const value_in_main_coinFull = eToNumber("16666666666666666666666666");

    console.log("nearMinimalFeeInUSD minimal_fee_in_usd " + minimal_fee_in_usd + " motoDexContract " + motoDexContract);
    return JSON.stringify({minimal_fee_in_usd: minimal_fee_in_usd});
}

async function nearMinimalFeeRate(mainnet, motoDexContract) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["get_minimal_fee_rate"], // view methods do not change state but usually return a value
            sender: account, // account object to initialize and sign transactions.
        }
    );

    console.log("nearMinimalFeeRate motoDexContract: " + motoDexContract);
    let minimal_fee_rate = await contract.get_minimal_fee_rate();
    console.log(minimal_fee_rate);

    console.log("nearMinimalFeeRate minimal_fee_in_usd " + minimal_fee_rate + " motoDexContract " + motoDexContract);
    return JSON.stringify(minimal_fee_rate);
}

async function nearLatestEpoch(mainnet, motoDexContract) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["get_latest_epoch_update"],
            sender: account, // account object to initialize and sign transactions.
        }
    );

    console.log("nearLatestEpochUpdate motoDexContract: " + motoDexContract);
    const latest_epoch_update = await contract.get_latest_epoch_update();
    console.log("latest_epoch_update = " + latest_epoch_update);

    console.log("nearMinimalFeeInUSD latest_epoch_update " + latest_epoch_update + " motoDexContract " + motoDexContract);
    window.web3gl.nearLatestEpochResponse = latest_epoch_update;
    return JSON.stringify({latest_epoch_update: latest_epoch_update});
}

async function nearGetLatestPrice(mainnet, motoDexContract) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["get_latest_price"], // Temporary
            sender: account, // account object to initialize and sign transactions.
        }
    );
    // console.log("contract " + contract);

    console.log("nearGetLatestPrice motoDexContract: " + motoDexContract);
    let get_latest_price;
    try {
        get_latest_price = await contract.get_latest_price();
        get_latest_price = '{"0":"' + get_latest_price + '","1":"1"}'
    } catch (error) {
        console.log(error.message);
        get_latest_price = [];
    }

    console.log("get_latest_price = " + get_latest_price);
    return get_latest_price;
}

async function nearSyncEpochResultsBidsFinal(mainnet, motoDexContract) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["sync_epoch_results_bids_final"], // Temporary
            sender: account, // account object to initialize and sign transactions.
        }
    );
    // console.log("contract " + contract);

    console.log("nearSyncEpochResultsBidsFinal motoDexContract: " + motoDexContract);
    let sync_epoch_results_bids_final;
    try {
        sync_epoch_results_bids_final = await contract.sync_epoch_results_bids_final();
    } catch (error) {
        console.log(error.message);
        sync_epoch_results_bids_final = [];
    }

    console.log("sync_epoch_results_bids_final = " + sync_epoch_results_bids_final);
    return JSON.stringify(sync_epoch_results_bids_final);
}

async function nearSyncEpochResultsMotosFinal(mainnet, motoDexContract) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["sync_epoch_results_motos_final"], // Temporary
            sender: account, // account object to initialize and sign transactions.
        }
    );
    // console.log("contract " + contract);

    console.log("nearSyncEpochResultsMotosFinal motoDexContract: " + motoDexContract);
    let sync_epoch_results_motos_final;
    try {
        sync_epoch_results_motos_final = await contract.sync_epoch_results_motos_final();
    } catch (error) {
        console.log(error.message);
        sync_epoch_results_motos_final = [];
    }

    console.log("sync_epoch_results_motos_final = " + sync_epoch_results_motos_final);
    return JSON.stringify(sync_epoch_results_motos_final);
}

async function nearHealthInWei(mainnet, motoDexContract, tokenId) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["get_token_health"], // view methods do not change state but usually return a value
            sender: account, // account object to initialize and sign transactions.
        }
    );

    console.log("nearHealthInWei motoDexContract: " + motoDexContract);
    const health_in_wei = await contract.get_token_health({ token_id : tokenId });
    console.log(health_in_wei);

    console.log("nearHealthInWei health_in_wei " + health_in_wei + " motoDexContract " + motoDexContract);
    return JSON.stringify({health_in_wei:health_in_wei});
}

async function nearGetPercentForTrack(mainnet, motoDexContract, tokenId) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["get_percent_for_track"], // view methods do not change state but usually return a value
            sender: account, // account object to initialize and sign transactions.
        }
    );

    console.log("nearGetPercentForTrack motoDexContract: " + motoDexContract);
    const response = await contract.get_percent_for_track({ token_id : tokenId });
    console.log(response);

    console.log("nearGetPercentForTrack get_percent_for_track " + response + " motoDexContract " + motoDexContract);
    return JSON.stringify(response);
}

async function nearGetTokenTypeNft(mainnet, motoDexContract, tokenId) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["get_token_type_nft"], // view methods do not change state but usually return a value
            sender: account, // account object to initialize and sign transactions.
        }
    );

    console.log("nearGetPercentForTrack motoDexContract: " + motoDexContract);
    const response = await contract.get_token_type_nft({ token_id : tokenId });
    console.log(response);

    console.log("nearGetTokenTypeNft get_token_type_nft " + response + " motoDexContract " + motoDexContract);
    return JSON.stringify(response);
}

async function nearGetGameSessions(mainnet, motoDexContract) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["get_active_sessions_full_view"], // view methods do not change state but usually return a value
            sender: account, // account object to initialize and sign transactions.
        }
    );

    console.log("nearGetGameSessions motoDexContract: " + motoDexContract);
    const response = await contract.get_active_sessions_full_view();
    console.log(response);

    console.log("nearMinimalFeeInUSD get_active_sessions_full_view " + response + " motoDexContract " + motoDexContract);
    return JSON.stringify(response);
}

async function nearGetAllGameBids(mainnet, motoDexContract) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["get_game_bids_paged"], // view methods do not change state but usually return a value
            sender: account, // account object to initialize and sign transactions.
        }
    );

    console.log("nearGetAllGameBids motoDexContract: " + motoDexContract);
    const response = await contract.get_game_bids_paged();
    console.log(response);

    console.log("nearMinimalFeeInUSD get_game_bids_paged " + response + " motoDexContract " + motoDexContract);
    return JSON.stringify(response);
}

async function nearBuyNFTFor(mainnet, motoDexContract, type, referral) {
    console.log("motoDexBuyNFTFor motoDexContract " + motoDexContract + "; NFT type " + type);
    mainnet = await checkNetwork(mainnet);

    let wallet = await connectNearWallet(mainnet)
    const contract = new nearApi.Contract(
        wallet.account(), // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            changeMethods: ["purchase"],
            sender: wallet.account(), // account object to initialize and sign transactions.
        }
    );
    // const amountString = eToNumber(amountInt);
    let parameters = {type_nft:type};
    if (referral !== null && referral !== undefined && referral.length > 2) parameters = {type_nft:type,referral:referral};
    const prices = await nearGetPriceForType(mainnet, motoDexContract, type);
    const pricesJSON = JSON.parse(prices);
    const value_in_main_coin = pricesJSON.value_in_main_coin;
    const buyResponse = await contract.purchase(parameters, "300000000000000", value_in_main_coin);
    return JSON.stringify(buyResponse);
}

async function nearAddHealthNFT(mainnet, motoDexContract, tokenId, healthPillTokenId) {
    console.log("motoDexBuyNFTFor motoDexContract " + motoDexContract + "; tokenId " + tokenId);
    mainnet = await checkNetwork(mainnet);

    let wallet = await connectNearWallet(mainnet)
    const contract = new nearApi.Contract(
        wallet.account(), // the account object that is connecting
        motoDexContract[0],// name of contract you're connecting to
        {
            changeMethods: ["add_health_nft"],
            sender: wallet.account(), // account object to initialize and sign transactions.
        }
    );
    console.log(wallet.account());
    const yoctoNear = "1";
    let parameters = {
        token_id:tokenId,
        health_pill_token_id:healthPillTokenId
    };


    const addHealthMoneyResponse = await contract.add_health_nft(parameters, "300000000000000", yoctoNear);
    return JSON.stringify(addHealthMoneyResponse);
}

async function nearAddHealthMoney(mainnet, motoDexContract, tokenId, value) {
    console.log("motoDexBuyNFTFor motoDexContract " + motoDexContract + "; tokenId " + tokenId);
    mainnet = await checkNetwork(mainnet);

    let wallet = await connectNearWallet(mainnet)
    const contract = new nearApi.Contract(
        wallet.account(), // the account object that is connecting
        motoDexContract[0],// name of contract you're connecting to
        {
            changeMethods: ["add_health_money"],
            sender: wallet.account(), // account object to initialize and sign transactions.
        }
    );
    console.log(wallet.account());
    let parameters = {token_id:tokenId};
    let value_in_main_coin;
    if (value != ""){
        value_in_main_coin = value;
    }
    else{
        const typeNft = await nearGetTokenTypeNft(mainnet, motoDexContract[0], tokenId);
        const prices = await nearGetPriceForType(mainnet, motoDexContract[0], typeNft);
        const pricesJSON = JSON.parse(prices);
        value_in_main_coin = pricesJSON.value_in_main_coin;
    }

    const addHealthMoneyResponse = await contract.add_health_money(parameters, "300000000000000", value_in_main_coin);
    return JSON.stringify(addHealthMoneyResponse);
}

async function nearBidFor(mainnet, motoDexContract, trackTokenId, motoTokenId, value) {
    console.log("motoDexBuyNFTFor motoDexContract " + motoDexContract + "; trackTokenId " + trackTokenId + "; motoTokenId " + motoTokenId);
    mainnet = await checkNetwork(mainnet);

    let wallet = await connectNearWallet(mainnet)
    const contract = new nearApi.Contract(
        wallet.account(), // the account object that is connecting
        motoDexContract[0],// name of contract you're connecting to
        {
            changeMethods: ["bid_for"],
            sender: wallet.account(), // account object to initialize and sign transactions.
        }
    );
    console.log(wallet.account());
    const yoctoNear = "1";
    let parameters = {
        track_token_id:trackTokenId,
        moto_token_id:motoTokenId
    };
    let value_in_main_coin = value;
    if (value_in_main_coin == null || value_in_main_coin == "0") value_in_main_coin = yoctoNear;

    const response = await contract.bid_for(parameters, "300000000000000", value_in_main_coin);
    return JSON.stringify(response);
}

async function nearAddMoto(mainnet, motoDexContract, tokenId) {
    console.log("nearAddMoto motoDexContract " + motoDexContract + "; NFT tokenId " + tokenId);
    console.log(mainnet);
    mainnet = await checkNetwork(mainnet);
    console.log(mainnet);

    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });

    let wallet = await connectNearWallet(mainnet)
    const contract = new nearApi.Contract(
        wallet.account(), // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            changeMethods: ["add_moto"],
            sender: wallet.account(), // account object to initialize and sign transactions.
        }
    );
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");
    const accountId = JSON.parse(account.connection.signer.keyStore.localStorage.OpenBiSea_wallet_auth_key).accountId;

    // const amountString = eToNumber(amountInt);
    // let parameters = {token_id:tokenId};

    const prices = await nearMinimalFeeInUSD(mainnet, motoDexContract[1]);
    const pricesJSON = JSON.parse(prices);
    const minimal_fee_in_usd = pricesJSON.minimal_fee_in_usd;
    // const addResponse = await contract.add_moto(parameters, "300000000000000", minimal_fee_in_usd);
    // return JSON.stringify(addResponse);

    const transactions = await nearAddTransactions(accountId, motoDexContract, tokenId, minimal_fee_in_usd, true, mainnet);
    return wallet.requestSignTransactions({ transactions });
}

async function nearAddTrack(mainnet, motoDexContract, tokenId) {
    console.log("nearAddTrack motoDexContract " + motoDexContract + "; NFT tokenId " + tokenId);
    mainnet = await checkNetwork(mainnet);

    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });

    let wallet = await connectNearWallet(mainnet)
    const contract = new nearApi.Contract(
        wallet.account(), // the account object that is connecting
        motoDexContract[0],// name of contract you're connecting to
        {
            changeMethods: ["add_track"],
            sender: wallet.account(), // account object to initialize and sign transactions.
        }
    );
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");
    const accountId = JSON.parse(account.connection.signer.keyStore.localStorage.OpenBiSea_wallet_auth_key).accountId;

    // // const amountString = eToNumber(amountInt);
    // let parameters = {token_id:tokenId};
    const prices = await nearMinimalFeeInUSD(mainnet, motoDexContract[1]);
    const pricesJSON = JSON.parse(prices);
    const minimal_fee_in_usd = pricesJSON.minimal_fee_in_usd;
    // const addResponse = await contract.add_moto(parameters, "300000000000000", minimal_fee_in_usd);
    // return JSON.stringify(addResponse);

    const transactions = await nearAddTransactions(accountId, motoDexContract, tokenId, minimal_fee_in_usd, false, mainnet);
    return wallet.requestSignTransactions({ transactions });
}

async function nearReturnMoto(mainnet, motoDexContract, tokenId) {
    console.log("nearReturnMoto motoDexContract " + motoDexContract + "; NFT tokenId " + tokenId);
    mainnet = await checkNetwork(mainnet);

    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });

    let wallet = await connectNearWallet(mainnet)
    const contract = new nearApi.Contract(
        wallet.account(), // the account object that is connecting
        motoDexContract[0],// name of contract you're connecting to
        {
            changeMethods: ["return_moto"],
            sender: wallet.account(), // account object to initialize and sign transactions.
        }
    );
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");
    const accountId = JSON.parse(account.connection.signer.keyStore.localStorage.OpenBiSea_wallet_auth_key).accountId;
    console.log("accountId: " + accountId);

    // // const amountString = eToNumber(amountInt);
    // let parameters = {token_id:tokenId};
    const yoctoNear = "1";
    // const addResponse = await contract.add_moto(parameters, "300000000000000", minimal_fee_in_usd);
    // return JSON.stringify(addResponse);

    const transactions = await nearReturnTransactions(accountId, motoDexContract, tokenId, yoctoNear, true, mainnet);
    return wallet.requestSignTransactions({ transactions });
}

async function nearUpdateCounter(mainnet, motoDexContract) {
    console.log("nearUpdateCounter motoDexContract " + motoDexContract);
    mainnet = await checkNetwork(mainnet);

    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });

    let wallet = await connectNearWallet(mainnet)
    const contract = new nearApi.Contract(
        wallet.account(), // the account object that is connecting
        motoDexContract[0],// name of contract you're connecting to
        {
            changeMethods: ["update_counter"],
            sender: wallet.account(), // account object to initialize and sign transactions.
        }
    );
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");
    const accountId = JSON.parse(account.connection.signer.keyStore.localStorage.OpenBiSea_wallet_auth_key).accountId;
    console.log("accountId: " + accountId);

    // // const amountString = eToNumber(amountInt);
    // let parameters = {token_id:tokenId};
    const yoctoNear = "1";
    // const addResponse = await contract.add_moto(parameters, "300000000000000", minimal_fee_in_usd);
    // return JSON.stringify(addResponse);

    const transactions = await nearUpdateCounterTransactions(accountId, motoDexContract, yoctoNear, mainnet) // nearReturnTransactions(accountId, motoDexContract, tokenId, yoctoNear, true, mainnet);
    return wallet.requestSignTransactions({ transactions });
}


async function nearReturnTrack(mainnet, motoDexContract, tokenId) {
    console.log("nearReturnTrack motoDexContract " + motoDexContract + "; NFT tokenId " + tokenId);
    mainnet = await checkNetwork(mainnet);

    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });

    let wallet = await connectNearWallet(mainnet)
    // const contract = new nearApi.Contract(
    //     wallet.account(), // the account object that is connecting
    //     motoDexContract[0],// name of contract you're connecting to
    //     {
    //         changeMethods: ["return_track"],
    //         sender: wallet.account(), // account object to initialize and sign transactions.
    //     }
    // );
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");
    const accountId = JSON.parse(account.connection.signer.keyStore.localStorage.OpenBiSea_wallet_auth_key).accountId;
    console.log("accountId: " + accountId);

    // // const amountString = eToNumber(amountInt);
    // let parameters = {token_id:tokenId};
    const yoctoNear = "1";
    console.log("minimal_fee_in_usd: " + minimal_fee_in_usd);
    // const addResponse = await contract.add_moto(parameters, "300000000000000", minimal_fee_in_usd);
    // return JSON.stringify(addResponse);

    const transactions = await nearReturnTransactions(accountId, motoDexContract, tokenId, yoctoNear, false, mainnet);
    return wallet.requestSignTransactions({ transactions });
}


async function nearAddTransactions(accountId, motoDexContract, tokenId, minimalFee, addMoto = true, mainnet) {
    const transactions = [];

    // Create transfer transaction
    // "receiver_id": "'$MOTODEX_CONTRACT'", "token_id": "1", "msg": "{\"action\":{\"type\":\"AddTrack\"}}"
    // const transferAction = {
    //     args: {
    //         receiver_id: motoDexContract[1], // NFT CONTRACT
    //         token_id: tokenId,
    //         msg: JSON.stringify({ action: { type: addMoto ? "AddMoto" : "AddTrack" } }),
    //     },
    //     gas: '50000000000000',
    //     deposit: "1",
    //     methodName: "nft_transfer_call",
    // };
    // const transferTransaction = await actionsToTransaction(
    //     accountId,
    //     motoDexContract[0],
    //     [transferAction]
    // );

    // transactions.push(transferTransaction);

    const addNFTAction = {
        args: {
            token_id: tokenId,
        },
        gas: '50000000000000',
        deposit: minimalFee, //nearApi.utils.format.parseNearAmount("0.1"),
        methodName: addMoto ? "add_moto" : "add_track",
    };
    const addNFTTransaction = await actionsToTransaction(
        accountId,
        motoDexContract[1],
        [addNFTAction],
        mainnet
    );

    transactions.push(addNFTTransaction);

    // return transactions
    return transactions;
}

async function nearReturnTransactions(accountId, motoDexContract, tokenId, minimalFee, returnMoto = true, mainnet) {
    const transactions = [];

    const returnNFTAction = {
        args: {
            token_id: tokenId,
        },
        gas: '50000000000000',
        deposit: minimalFee,
        methodName: returnMoto ? "return_moto" : "return_track",
    };
    const returnNFTTransaction = await actionsToTransaction(
        accountId,
        motoDexContract[1],
        [returnNFTAction],
        mainnet
    );

    transactions.push(returnNFTTransaction);

    // return transactions
    return transactions;
}

async function nearUpdateCounterTransactions(accountId, motoDexContract, minimalFee, mainnet) {
    const transactions = [];

    const updateCounterAction = {
        args: {
        },
        gas: '50000000000000',
        deposit: minimalFee,
        methodName: "update_counter",
    };
    const updateCounterTransaction = await actionsToTransaction(
        accountId,
        motoDexContract[1],
        [updateCounterAction],
        mainnet
    );

    transactions.push(updateCounterTransaction);

    // return transactions
    return transactions;
}

async function actionsToTransaction(accountId, receiverId, actions, mainnet) {
    return await createTx(
        accountId,
        receiverId,
        actions.map((action) =>
            nearApi.transactions.functionCall(
                action.methodName,
                action.args,
                action.gas,
                action.deposit,
            )
        ),
        mainnet
    );
}

async function createTx(
    accountId,
    receiverId,
    actions,
    mainnet,
    nonceOffset = 1
) {
    let wallet = await connectNearWallet(mainnet);
    console.log('connection', wallet);
    // if (!wallet.isSignedIn()) {
    //     await wallet.requestSignIn(
    //         contractAccount,
    //         'MotoDex'
    //     );
    // }
    const account = wallet.account();

    const connection = account.connection;

    account.accountId = accountId;
    const localKey = await connection.signer.getPublicKey(
        account.accountId,
        connection.networkId
    );

    const accessKey = await account.accessKeyForTransaction(
        receiverId,
        actions,
        localKey
    );

    if (!accessKey) {
        throw new Error(
            `Cannot find matching key for transaction sent to ${receiverId}`
        );
    }

    const block = await connection.provider.block({ finality: "final" });
    const blockHash = borsh.baseDecode(block.header.hash);

    const publicKey = nearApi.utils.PublicKey.from(accessKey.public_key);
    const nonce = accessKey.access_key.nonce + nonceOffset;

    return nearApi.transactions.createTransaction(
        account.accountId,
        publicKey,
        receiverId,
        nonce,
        actions,
        blockHash
    );
}

async function listNearNFTsWeb(mainnet, contractAddress, selectedAccount) {
    console.log("listNearNFTsWeb network " + mainnet + "; motoDexContract " + contractAddress + "; selectedAccount " + selectedAccount);
    mainnet = await checkNetwork(mainnet);

    let wallet = await connectNearWallet(mainnet)
    const contract = new nearApi.Contract(
        wallet.account(), // the account object that is connecting
        contractAddress,// name of contract you're connecting to
        {
            viewMethods: ["nft_tokens_for_owners"], // view methods do not change state but usually return a value
            sender: wallet.account(), // account object to initialize and sign transactions.
        }
    );
    // console.log("listNearNFTsWeb contract " + contract);

    const nft_tokens_for_owner = await contract.nft_tokens_for_owners({ account_id: selectedAccount });
    window.web3gl.listNearNFTsWebResponse = JSON.stringify(nft_tokens_for_owner);
    return JSON.stringify(nft_tokens_for_owner);
}

async function nearSendContract(mainnet, motoDexContract, method, args, value) {
    args = JSON.parse(args);
    motoDexContract = JSON.parse(motoDexContract);
    console.log(args);
    console.log(args[0]);
    let response;
    mainnet = await checkNetwork(mainnet);
    switch (method) {
        case "purchase" :
            response = await nearBuyNFTFor(mainnet, motoDexContract[0], parseInt(args[0]), args[1]);
            break;
        case "addMoto" :
            response = await nearAddMoto(mainnet, motoDexContract,  String(args[0]));
            break;
        case "addTrack" :
            response = await nearAddTrack(mainnet, motoDexContract, String(args[0]));
            break;
        case "returnMoto" :
            response = await nearReturnMoto(mainnet, motoDexContract, String(args[0]));
            break;
        case "UpdateCounter" :
            response = await nearUpdateCounter(mainnet, motoDexContract);
            break;
        case "returnTrack" :
            response = await nearReturnTrack(mainnet, motoDexContract, String(args[0]));
            break;
        case "addHealthNFT" :
            response = await nearAddHealthNFT(mainnet, motoDexContract, String(args[0]),  String(args[1]));
            break;
        case "addHealthMoney" :
            response = await nearAddHealthMoney(mainnet, motoDexContract, String(args[0]), value);
            break;
        case "bidFor" :
            response = await nearBidFor(mainnet, motoDexContract, String(args[0]),  String(args[1]), value);
            break;
        default:
            alert('Method is not added');
    }
    if (typeof response != "string")
    {
        window.web3gl.nearSendContractResponse = JSON.stringify(response);
    }
    else
    {
        window.web3gl.nearSendContractResponse = response;
    }
}

async function nearMethodCall(mainnet, motoDexContract, method, args, value) {
    args = JSON.parse(args);
    motoDexContract = JSON.parse(motoDexContract);
    console.log(args);
    console.log(args[0]);
    let response;
    console.log(method);
    mainnet = await checkNetwork(mainnet);
    switch (method) {
        case "tokenIdsAndOwners" :
            response = await nearTokenIdsAndOwners(mainnet, motoDexContract[1]);
            break;
        case "getPriceForType" :
            response = await nearGetPriceForType(mainnet, motoDexContract[1], parseInt(args[0]));
            response = JSON.parse(response).get_price_for_type;
            break;
        case "getMinimalFeeRate" :
            response = await nearMinimalFeeRate(mainnet, motoDexContract[1]);
            break;
        case "valueInMainCoin" :
            response = await nearGetPriceForType(mainnet, motoDexContract[1], parseInt(args[0]));
            response = JSON.parse(response).value_in_main_coinFull;
            break;
        case "valueInMainCoinCorrect" :
            response = await nearGetPriceForType(mainnet, motoDexContract[1], parseInt(args[0]));
            response = JSON.parse(response).value_in_main_coin_correct;
            break;
        case "getHealthForId" :
            response = await nearHealthInWei(mainnet, motoDexContract[1], args[0]);
            response =  JSON.parse(response).health_in_wei;
            break;
        case "getPercentForTrack" :
            response = await nearGetPercentForTrack(mainnet, motoDexContract[1], args[0]);
            break;
        case "getGameSessions" :
            response = await nearGetGameSessions(mainnet, motoDexContract[1]);
            break;
        case "getAllGameBids" :
            response = await nearGetAllGameBids(mainnet, motoDexContract[1]);
            break;
        case "latestEpochUpdate" :
            response = await nearLatestEpochUpdate(mainnet, motoDexContract[1]);
            response =  JSON.parse(response).epoch_min_interval;
            break;
        case "getLatestPrice" :
            response = await nearGetLatestPrice(mainnet, motoDexContract[1]);
            break;
        case "syncEpochResultsBidsFinal" :
            response = await nearSyncEpochResultsBidsFinal(mainnet, motoDexContract[1]);
            break;
        case "syncEpochResultsMotosFinal" :
            response = await nearSyncEpochResultsMotosFinal(mainnet, motoDexContract[1]);
            break;
        default:
            alert('Method is not added');
    }
    if (typeof response != "string")
    {
        window.web3gl.nearMethodCallResponse = JSON.stringify(response);
    }
    else
    {
        window.web3gl.nearMethodCallResponse = response;
    }
}
async function nearTokenIdsAndOwners(mainnet, motoDexContract) {
    mainnet = await checkNetwork(mainnet);
    const near = new nearApi.Near({
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
        networkId: mainnet ? 'default' : 'testnet',
        nodeUrl: mainnet ? 'https://rpc.mainnet.near.org' : 'https://rpc.testnet.near.org',
        walletUrl: mainnet ? 'https://app.mynearwallet.com' : 'https://wallet.testnet.near.org'
    });
    const account = await near.account(mainnet ? "openbisea.near" : "openbisea1.testnet");

    const contract = new nearApi.Contract(
        account, // the account object that is connecting
        motoDexContract,// name of contract you're connecting to
        {
            viewMethods: ["token_ids_and_owners"], // view methods do not change state but usually return a value
            sender: account, // account object to initialize and sign transactions.
        }
    );

    console.log("nearTokenIdsAndOwners motoDexContract: " + motoDexContract);
    const token_ids_and_owners = await contract.token_ids_and_owners();
    console.log("nearTokenIdsAndOwners");
    console.log(token_ids_and_owners);
    return JSON.stringify(token_ids_and_owners);
}

async function concordiumCheckTransactionStatus(txHash, client) {

    let txStatus = await client.getTransactionStatus(txHash);

    while (txStatus.status == 'received') {
        // Wait for a few seconds before checking again
        await new Promise(resolve => setTimeout(resolve, 5000));
        txStatus = await client.getTransactionStatus(txHash);
    }

    const resultOutcome = Object.values(txStatus.outcomes)[0].result.outcome;
    console.log('resultOutcome:', resultOutcome);

    if (resultOutcome == 'success') {
        return 'success';
    } else if (resultOutcome =='reject') {
        const rejectReason = Object.values(txStatus.outcomes)[0].result.rejectReason;
        console.log('Reject reason:', rejectReason);
        return 'fail';
    }

    return 'fail';
}

async function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function eToNumber(num) {
    let sign = "";
    (num += "").charAt(0) == "-" && (num = num.substring(1), sign = "-");
    let arr = num.split(/[e]/ig);
    if (arr.length < 2) return sign + num;
    let dot = (.1).toLocaleString().substr(1, 1), n = arr[0], exp = +arr[1],
        w = (n = n.replace(/^0+/, '')).replace(dot, ''),
        pos = n.split(dot)[1] ? n.indexOf(dot) + exp : w.length + exp,
        L   = pos - w.length, s = "" + BigInt(w);
    w   = exp >= 0 ? (L >= 0 ? s + "0".repeat(L) : r()) : (pos <= 0 ? "0" + dot + "0".repeat(Math.abs(pos)) + s : r());
    L= w.split(dot); if (L[0]==0 && L[1]==0 || (+w==0 && +s==0) ) w = 0; //** added 9/10/2021
    return sign + w;
    function r() {return w.replace(new RegExp(`^(.{${pos}})(.)`), `$1${dot}$2`)}
}

async function checkNetwork(mainnet) {
    switch (mainnet) {
        case "testnet" :
            mainnet = false;
            break;
        case "mainnet" :
            mainnet = true;
            break;
        case true :
            mainnet = true;
            break;
        default:
            mainnet = false;
    }
    return mainnet;
}

async function webGLReload(clearCookies = "True"){
    if (clearCookies == "True"){
        try {
            window.localStorage.clear();
        } catch (error) {
            console.log("Removing cookes error: " + error);
        }
    }

    //setTimeout(() => { window.location.reload(); }, 100);
}

async function googleAnalyticsSendEvent(eventName) {
    console.log("googleAnalyticsSendEvent: " + eventName);
    gtag('event', eventName, { eventName: true });
}

async function initializeWeb3Modal() {
    
    console.log("web3modal exists - ", window.web3modal);
    
    if (!window.web3modal) {
        const defaultChain = window.chains.find(chain => chain.id == window.web3ChainId) || window.chains[0];
        console.log("init chain - ", defaultChain);
        window.web3modal = new Web3Modal({
            projectId: window.projectId,
            defaultChain: defaultChain,
            themeMode: 'dark'
        }, window.ethereumClient);
        console.log("Web3Modal initialized with chain ID:", defaultChain.id);
    }
    return window.web3modal;
}

async function switchToCorrectNetwork() {
    console.log("Switch network");
    
    if (!window.ethereum || !window.switchNetwork || !window.chains || !window.web3ChainId) {
        console.error("Required properties are not available on the window object");
        return;
    }
    console.log("Chains:", window.chains);
    console.log("Current Chain ID:", window.web3ChainId);
    const desiredChain = window.chains.find(chain => chain.id == window.web3ChainId);
    console.log("Desired chain:", desiredChain);
    if (!desiredChain) {
        console.error("Desired chain not found in the list of supported chains");
        return;
    }

    async function addNetwork() {
        console.log("window ethereum - ", window.ethereum);
        
        return window.ethereum.request({
            method: 'wallet_addEthereumChain',
            params: [{
                chainId: `0x${desiredChain.id.toString(16)}`,
                chainName: desiredChain.name,
                nativeCurrency: desiredChain.nativeCurrency,
                rpcUrls: desiredChain.rpcUrls.default.http,
                blockExplorerUrls: [desiredChain.blockExplorers.default.url],
            }],
        });
    }

    async function switchToNetwork() {
        return window.switchNetwork({ chainId: desiredChain.id });
    }

    try {
        await switchToNetwork();
        console.log("Switched to network successfully");
    } catch (switchError) {
        console.error("Error switching network:", switchError);
        console.log("error code - ", switchError.code);
        if (switchError.code === 4902 || switchError.code === undefined) {
            try {
                console.log("Network not found. Attempting to add...");
                await addNetwork();
                console.log("Network added successfully. Attempting to switch...");
                await switchToNetwork();
                console.log("Switched to newly added network successfully");
            } catch (addError) {
                console.error("Failed to add or switch to the network:", addError);
                throw addError;  
            }
        } else {
            console.log("throw error");
            throw switchError;
        }
    }
}
// View methods
// !!tokenURI : tokenId (uint256)
// !!getHealthForId : tokenId (uint256)
// !!getPercentForTrack : tokenId (uint256)
// !!balanceOf : owner (address)
// latestEpochUpdate : "[]"
// !!getGameSessions : "[]"
// !!getAllGameBids : "[]"
// getLatestPrice : "[]"
// syncEpochResultsBidsFinal : "[]"
// syncEpochResultsMotosFinal : "[]"
// getLimitsAndCounters : "[]"

// Change methods
// !!addHealthNFT : ""; tokenId (uint256), healthPillTokenId (uint256)
// !!bidFor : bidFor; trackTokenId (uint8), motoTokenId (uint8)
// !!addHealthMoney : addHealthMoney; tokenId (uint256)
